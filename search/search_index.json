{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Simple Weather","text":"<p>A beginner-friendly Python package for fetching weather data, designed for educational use.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>\ud83c\udf24\ufe0f Easy access to weather data from wttr.in</li> <li>\ud83c\udf19 Moon phase information</li> <li>\ud83d\uddfa\ufe0f Location-based weather (cities, airports, coordinates)</li> <li>\ud83c\udf0d Multiple language support</li> <li>\ud83d\udcca Multiple output formats: text, JSON (with Pydantic models), raw JSON (Python dictionaries), and PNG images</li> <li>\ud83d\ude80 Built-in caching to be nice to the wttr.in service</li> <li>\ud83d\udee1\ufe0f Beginner-friendly error handling (no exceptions)</li> <li>\ud83d\udcda Designed for teaching Python and API interactions</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install fetch-my-weather\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>import fetch_my_weather\n\n# Get weather for your current location (based on IP)\ncurrent_weather = fetch_my_weather.get_weather()\nprint(current_weather)\n\n# Get weather for Berlin in metric units\nberlin_weather = fetch_my_weather.get_weather(location=\"Berlin\", units=\"m\")\nprint(berlin_weather)\n\n# Get moon phase for a specific date\nmoon = fetch_my_weather.get_weather(is_moon=True, moon_date=\"2025-07-04\")\nprint(moon)\n</code></pre>"},{"location":"#navigation","title":"Navigation","text":"<ul> <li>Check out the User Guide for detailed usage instructions</li> <li>Explore the Mini-Projects for practical examples</li> <li>See the Teaching Guide for educational applications</li> <li>Review the Technical Documentation for implementation details</li> </ul>"},{"location":"#contributors","title":"Contributors","text":"<p>This project is maintained by Michael Borck with contributions from various individuals. See the AUTHORS file for a complete list of contributors.</p>"},{"location":"#acknowledgments","title":"Acknowledgments","text":"<p>This package is a wrapper around the amazing wttr.in service created by Igor Chubin. Please be respectful of the wttr.in service by not making too many requests.</p>"},{"location":"LICENSE/","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2025 Your Name</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"design-doc/","title":"Design Philosophy of fetch-my-weather","text":"<p>This document explains the design decisions behind the <code>fetch-my-weather</code> package, focusing on educational principles, simplicity, and accessibility.</p>"},{"location":"design-doc/#core-design-principles","title":"Core Design Principles","text":""},{"location":"design-doc/#1-education-first","title":"1. Education First","text":"<p>The entire package was designed with education as the primary goal. All design decisions prioritize teaching value over advanced features or optimal performance. This means:</p> <ul> <li>Code is clearly structured and well-documented</li> <li>Functions have descriptive names</li> <li>Complex operations are broken down into smaller steps</li> <li>Implementation details are visible and understandable</li> </ul>"},{"location":"design-doc/#2-beginner-accessibility","title":"2. Beginner Accessibility","text":"<p>The API is intentionally designed to be approachable for beginners:</p> <ul> <li>A single main function (<code>get_weather()</code>) handles all functionality</li> <li>Parameters have sensible defaults</li> <li>Return values are simple (strings or bytes)</li> <li>Error handling avoids exceptions in favor of descriptive messages</li> </ul>"},{"location":"design-doc/#3-minimalism","title":"3. Minimalism","text":"<p>The package follows a minimalist approach:</p> <ul> <li>Small codebase (only two files)</li> <li>Single external dependency (requests library)</li> <li>Focused functionality with no feature bloat</li> <li>Simple data structures</li> </ul>"},{"location":"design-doc/#4-practical-learning","title":"4. Practical Learning","text":"<p>While simplified, the package implements real-world programming practices:</p> <ul> <li>Proper API handling with parameter encoding</li> <li>Effective caching for performance</li> <li>HTTP request management</li> <li>Content type handling</li> <li>User-Agent configuration</li> </ul>"},{"location":"design-doc/#design-decisions","title":"Design Decisions","text":""},{"location":"design-doc/#why-a-single-function-api","title":"Why a Single Function API?","text":"<p>The main API consists of a single function with multiple parameters rather than separate functions for different features:</p> <pre><code>get_weather(location=\"\", units=\"\", view_options=\"\", lang=None,\n            is_png=False, png_options=\"\", is_moon=False,\n            moon_date=None, moon_location_hint=None)\n</code></pre> <p>Rationale: - Easier to learn (one function vs. many) - Parameters naturally group related options - Consistent with the underlying API - Reduces cognitive load for beginners</p>"},{"location":"design-doc/#why-return-strings-not-objects","title":"Why Return Strings, Not Objects?","text":"<p>Unlike many modern API wrappers, <code>fetch-my-weather</code> returns plain text strings or raw bytes instead of parsed data structures.</p> <p>Rationale: - Output is immediately useful without further processing - Beginners can see the actual data format - No need to learn complex object models - Matches the console-oriented nature of the weather service</p>"},{"location":"design-doc/#why-no-exceptions","title":"Why No Exceptions?","text":"<p>The package never raises exceptions to the caller, instead returning error messages as strings.</p> <p>Rationale: - Exception handling is often confusing for beginners - Pattern-based error checking (<code>if result.startswith(\"Error:\")</code>) is easy to understand - Consistent with the string-based return values - Simpler control flow in user code</p>"},{"location":"design-doc/#why-in-memory-caching","title":"Why In-Memory Caching?","text":"<p>The package uses a simple dictionary-based in-memory cache rather than a more sophisticated caching system.</p> <p>Rationale: - Transparent implementation that can be easily understood - No external dependencies for caching - Sufficient for educational purposes - Demonstrates basic cache concepts (storage, expiration, lookup)</p>"},{"location":"design-doc/#why-url-construction","title":"Why URL Construction?","text":"<p>Significant code is dedicated to URL construction rather than using a more abstracted approach.</p> <p>Rationale: - Shows how API endpoints are constructed - Demonstrates URL encoding concepts - Provides insight into query parameter formatting - Reveals the differences between API formats (text vs. PNG, etc.)</p>"},{"location":"design-doc/#educational-value","title":"Educational Value","text":"<p>Each component of the package offers specific educational opportunities:</p>"},{"location":"design-doc/#url-construction","title":"URL Construction","text":"<ul> <li>Learning about URL structure</li> <li>Query parameter formatting</li> <li>URL encoding (handling spaces, special characters)</li> <li>Differences between path parameters and query parameters</li> </ul>"},{"location":"design-doc/#caching","title":"Caching","text":"<ul> <li>Basic caching concepts</li> <li>Time-based expiration</li> <li>Memory management</li> <li>Performance optimization</li> </ul>"},{"location":"design-doc/#http-requests","title":"HTTP Requests","text":"<ul> <li>Making network requests</li> <li>Setting headers</li> <li>Handling different content types</li> <li>Understanding status codes</li> </ul>"},{"location":"design-doc/#parameter-handling","title":"Parameter Handling","text":"<ul> <li>Input validation</li> <li>Optional parameters with defaults</li> <li>Parameter combining and formatting</li> </ul>"},{"location":"design-doc/#comparisons-with-alternatives","title":"Comparisons with Alternatives","text":"<p>The design of <code>fetch-my-weather</code> differs from many modern API wrappers and weather libraries:</p>"},{"location":"design-doc/#compared-to-type-safe-model-based-wrappers-like-existing-pywttr","title":"Compared to Type-Safe, Model-Based Wrappers (like existing pywttr):","text":"<ul> <li>Simpler return types (strings vs. nested objects)</li> <li>Fewer dependencies (no need for Pydantic, etc.)</li> <li>More educational visibility into raw data</li> <li>Less code to understand for beginners</li> </ul>"},{"location":"design-doc/#compared-to-full-featured-weather-libraries","title":"Compared to Full-Featured Weather Libraries:","text":"<ul> <li>More focused functionality</li> <li>Lighter weight</li> <li>Lower conceptual overhead</li> <li>More suited to teaching basic API concepts</li> </ul>"},{"location":"design-doc/#future-design-considerations","title":"Future Design Considerations","text":"<p>While maintaining the educational focus, future versions might consider:</p> <ol> <li> <p>Optional Structured Data: Adding an optional parameter to return structured data for advanced users</p> </li> <li> <p>More Backend Services: Supporting additional weather data sources while maintaining the same simple interface</p> </li> <li> <p>Enhanced Educational Resources: Adding more inline documentation focused on teaching concepts</p> </li> <li> <p>Interactive Examples: Providing Jupyter notebook examples that walk through each feature</p> </li> </ol>"},{"location":"design-doc/#conclusion","title":"Conclusion","text":"<p>The design of <code>fetch-my-weather</code> deliberately prioritizes educational value, beginner accessibility, and conceptual clarity over advanced features, optimal performance, or industrial robustness. This makes it an ideal tool for teaching basic concepts of API interaction, network requests, and data handling in Python.</p>"},{"location":"publishing-guide/","title":"Publishing Guide for fetch-my-weather","text":"<p>This guide walks you through the process of publishing your <code>fetch-my-weather</code> package to PyPI using modern Python tooling.</p>"},{"location":"publishing-guide/#prerequisites","title":"Prerequisites","text":"<p>Make sure you have the following installed:</p> <pre><code># Install uv for environment and package management\npip install uv\n\n# Create and activate virtual environment with uv\nuv venv\nsource .venv/bin/activate  # On Unix/MacOS\n# .venv\\Scripts\\activate  # On Windows\n\n# Install development dependencies\nuv pip install -e \".[dev]\"\n</code></pre> <p>You'll also need accounts on: - PyPI (for final publishing) - TestPyPI (for testing)</p>"},{"location":"publishing-guide/#step-1-update-your-package-information","title":"Step 1: Update Your Package Information","text":"<p>Edit the following files with your personal information:</p> <ol> <li><code>pyproject.toml</code>: Update the author name, email, and GitHub username</li> <li><code>LICENSE</code>: Add your name and the current year</li> <li><code>README.md</code>: Make any final adjustments to the documentation</li> </ol>"},{"location":"publishing-guide/#step-2-validate-your-code","title":"Step 2: Validate Your Code","text":"<p>Before publishing, verify that your code passes all quality checks:</p> <pre><code># Type checking with mypy\nmypy src/fetch_my_weather\n\n# Linting with ruff\nruff check src/fetch_my_weather\n\n# Formatting with ruff\nruff format src/fetch_my_weather\n\n# Run tests with pytest\npytest\n</code></pre>"},{"location":"publishing-guide/#step-3-build-your-package","title":"Step 3: Build Your Package","text":"<p>From the root directory of your project, run:</p> <pre><code>python -m build\n</code></pre> <p>This will create two files in the <code>dist/</code> directory: - A source distribution (<code>.tar.gz</code>) - A wheel (<code>.whl</code>)</p>"},{"location":"publishing-guide/#step-4-test-your-package-on-testpypi","title":"Step 4: Test Your Package on TestPyPI","text":"<p>Upload to TestPyPI first to make sure everything works:</p> <pre><code># Using twine 6.0.1 as specified\ntwine upload --repository testpypi dist/*\n</code></pre> <p>You'll be prompted for your TestPyPI username and password.</p>"},{"location":"publishing-guide/#step-5-verify-your-testpypi-upload","title":"Step 5: Verify Your TestPyPI Upload","text":"<p>Create a new virtual environment and try installing your package from TestPyPI:</p> <pre><code># Create and activate a clean virtual environment with uv\nuv venv test_env\nsource test_env/bin/activate  # On Unix/MacOS\n# test_env\\Scripts\\activate  # On Windows\n\n# Install your package from TestPyPI\nuv pip install --index-url https://test.pypi.org/simple/ --extra-index-url https://pypi.org/simple/ fetch-my-weather\n\n# Test that it works\npython -c \"import fetch_my_weather; print(fetch_my_weather.__version__)\"\n</code></pre>"},{"location":"publishing-guide/#step-6-publish-to-real-pypi","title":"Step 6: Publish to Real PyPI","text":"<p>If everything looks good on TestPyPI, upload to the real PyPI:</p> <pre><code>twine upload dist/*\n</code></pre>"},{"location":"publishing-guide/#step-7-verify-your-pypi-upload","title":"Step 7: Verify Your PyPI Upload","text":"<p>Create another fresh virtual environment and install your package from the real PyPI:</p> <pre><code># Create and activate a clean virtual environment with uv\nuv venv verify_env\nsource verify_env/bin/activate  # On Unix/MacOS\n# verify_env\\Scripts\\activate  # On Windows\n\n# Install your package from PyPI\nuv pip install fetch-my-weather\n\n# Test that it works\npython -c \"import fetch_my_weather; print(fetch_my_weather.__version__)\"\n</code></pre>"},{"location":"publishing-guide/#congratulations","title":"Congratulations!","text":"<p>Your <code>fetch-my-weather</code> package is now published and available for anyone to install using <code>pip install fetch-my-weather</code>!</p>"},{"location":"publishing-guide/#updating-your-package-later","title":"Updating Your Package Later","text":"<p>When you want to release a new version:</p> <ol> <li>Update the version number in <code>fetch_my_weather/__init__.py</code></li> <li>Make your code changes</li> <li>Run quality checks (mypy, ruff, pytest)</li> <li>Rebuild using <code>python -m build</code></li> <li>Upload the new version with <code>twine upload dist/*</code></li> </ol>"},{"location":"publishing-guide/#additional-resources","title":"Additional Resources","text":"<ul> <li>Python Packaging User Guide</li> <li>Packaging Python Projects Tutorial</li> <li>TestPyPI Guide</li> <li>uv Documentation</li> <li>ruff Documentation</li> <li>mypy Documentation</li> </ul>"},{"location":"teaching-guide/","title":"Teaching Guide for fetch-my-weather","text":"<p>This guide is designed to help educators use the <code>fetch-my-weather</code> package as a teaching tool in programming courses. It includes suggested lesson plans, learning objectives, and teaching approaches for different skill levels.</p>"},{"location":"teaching-guide/#teaching-philosophy","title":"Teaching Philosophy","text":"<p>The <code>fetch-my-weather</code> package was specifically designed to support programming education by providing:</p> <ol> <li>Accessible API Interactions: Students can make real API calls without complex authentication or setup</li> <li>Immediate Visual Feedback: Weather reports provide engaging, meaningful output</li> <li>Graduated Complexity: Start simple, then introduce more advanced features</li> <li>Real-world Application: Students learn with a practical tool rather than contrived examples</li> </ol>"},{"location":"teaching-guide/#learning-objectives","title":"Learning Objectives","text":""},{"location":"teaching-guide/#beginner-level","title":"Beginner Level","text":"<ul> <li>Making function calls with parameters</li> <li>Reading and interpreting text output</li> <li>Basic error handling</li> <li>String operations</li> <li>File I/O (when saving PNG files)</li> </ul>"},{"location":"teaching-guide/#intermediate-level","title":"Intermediate Level","text":"<ul> <li>Working with APIs</li> <li>Handling different data formats (text vs. binary)</li> <li>Implementing caching concepts</li> <li>Parameter combinations for different output formats</li> <li>Creating small applications with external data</li> </ul>"},{"location":"teaching-guide/#advanced-level","title":"Advanced Level","text":"<ul> <li>Understanding URL construction for APIs</li> <li>Analyzing network traffic</li> <li>Implementing more sophisticated caching mechanisms</li> <li>Creating GUIs that display weather data</li> <li>Building on top of existing packages</li> </ul>"},{"location":"teaching-guide/#suggested-course-integration","title":"Suggested Course Integration","text":""},{"location":"teaching-guide/#python-basics-course-week-3-4","title":"Python Basics Course (Week 3-4)","text":"<p>Introduce <code>fetch-my-weather</code> after students have learned: - Basic function calls - If statements - String operations - Print statements</p>"},{"location":"teaching-guide/#web-programming-course","title":"Web Programming Course","text":"<p>Use <code>fetch-my-weather</code> as an introduction to: - API concepts - HTTP requests - Working with web services - Before tackling more complex APIs that require authentication</p>"},{"location":"teaching-guide/#data-science-introduction","title":"Data Science Introduction","text":"<p>Incorporate <code>fetch-my-weather</code> when teaching: - External data retrieval - Data parsing (from text to structured data) - Visualization of data</p>"},{"location":"teaching-guide/#lesson-plan-examples","title":"Lesson Plan Examples","text":""},{"location":"teaching-guide/#lesson-1-introduction-to-apis-60-minutes","title":"Lesson 1: Introduction to APIs (60 minutes)","text":"<p>Objectives: - Understand what an API is - Learn how to make basic API calls - Interpret returned data</p> <p>Activities: 1. Introduction (10 min)    - Explain what APIs are and why they're important    - Introduce the weather service concept</p> <ol> <li>Demonstration (15 min)</li> <li>Show installation of <code>fetch-my-weather</code></li> <li>Demonstrate basic weather retrieval</li> <li> <p>Show different locations</p> </li> <li> <p>Guided Practice (20 min)</p> </li> <li>Students retrieve weather for their city</li> <li>Students try different view options</li> <li> <p>Students try different units</p> </li> <li> <p>Discussion (10 min)</p> </li> <li>What information is included in the weather report?</li> <li>How might this data be useful in applications?</li> <li> <p>What other APIs might exist in the world?</p> </li> <li> <p>Assessment (5 min)</p> </li> <li>Quick quiz on API concepts</li> </ol>"},{"location":"teaching-guide/#lesson-2-error-handling-45-minutes","title":"Lesson 2: Error Handling (45 minutes)","text":"<p>Objectives: - Learn to check for and handle errors - Understand why error handling is important</p> <p>Activities: 1. Review (5 min)    - Quick recap of API calls</p> <ol> <li>Demonstration (10 min)</li> <li>Show what happens with invalid locations</li> <li> <p>Demonstrate how to check for error responses</p> </li> <li> <p>Guided Practice (20 min)</p> </li> <li>Students intentionally create error conditions</li> <li>Students write code to handle errors gracefully</li> <li> <p>Students create a function that retries on error</p> </li> <li> <p>Discussion (10 min)</p> </li> <li>Why is error handling important in real applications?</li> <li>How does this approach differ from exceptions?</li> </ol>"},{"location":"teaching-guide/#lesson-3-working-with-different-data-formats-90-minutes","title":"Lesson 3: Working with Different Data Formats (90 minutes)","text":"<p>Objectives: - Understand differences between text and binary data - Learn to save and work with image files</p> <p>Activities: 1. Introduction (15 min)    - Explain text vs. binary data    - Discuss image file formats briefly</p> <ol> <li>Demonstration (20 min)</li> <li>Show retrieving weather as text</li> <li>Show retrieving weather as PNG</li> <li> <p>Demonstrate saving PNG to a file</p> </li> <li> <p>Guided Practice (40 min)</p> </li> <li> <p>Students create a program that:</p> <ul> <li>Gets weather for multiple cities</li> <li>Saves each as a PNG file</li> <li>Creates an HTML page that displays all images</li> </ul> </li> <li> <p>Discussion (15 min)</p> </li> <li>What are the advantages/disadvantages of each format?</li> <li>How might these formats be used in different applications?</li> </ol>"},{"location":"teaching-guide/#teaching-approaches","title":"Teaching Approaches","text":""},{"location":"teaching-guide/#scaffolded-learning","title":"Scaffolded Learning","text":"<p>Start with the simplest form of the API and gradually introduce more parameters:</p> <ol> <li>Basic retrieval: <code>weather = fetch_my_weather.get_weather()</code></li> <li>Add location: <code>weather = fetch_my_weather.get_weather(location=\"Tokyo\")</code></li> <li>Add view options: <code>weather = fetch_my_weather.get_weather(location=\"Tokyo\", view_options=\"q\")</code></li> <li>Add units: <code>weather = fetch_my_weather.get_weather(location=\"Tokyo\", view_options=\"q\", units=\"u\")</code></li> </ol>"},{"location":"teaching-guide/#problem-based-learning","title":"Problem-Based Learning","text":"<p>Present students with problems to solve:</p> <ol> <li>\"Create a program that shows the weather for 5 major world cities\"</li> <li>\"Build a tool that compares current temperature across continents\"</li> <li>\"Design a daily weather reporter that runs automatically\"</li> </ol>"},{"location":"teaching-guide/#code-reading-exercises","title":"Code Reading Exercises","text":"<p>Have students read and explain code that uses <code>fetch-my-weather</code>:</p> <pre><code>import fetch_my_weather\n\ndef compare_temperatures(cities):\n    results = {}\n    for city in cities:\n        weather = fetch_my_weather.get_weather(location=city)\n        if isinstance(weather, str) and not weather.startswith(\"Error:\"):\n            # Extract temperature from the text (simplistic approach)\n            if \"\u00b0C\" in weather:\n                temp_parts = weather.split(\"\u00b0C\")[0].split()\n                temp = temp_parts[-1]\n                results[city] = temp + \"\u00b0C\"\n    return results\n\ncities = [\"London\", \"Tokyo\", \"New York\", \"Sydney\", \"Cape Town\"]\ntemperatures = compare_temperatures(cities)\nfor city, temp in temperatures.items():\n    print(f\"{city}: {temp}\")\n</code></pre>"},{"location":"teaching-guide/#pair-programming","title":"Pair Programming","text":"<p>Have students work in pairs: - One student writes code to retrieve weather data - The other student writes code to process or display it - Then they integrate their code</p>"},{"location":"teaching-guide/#assessment-ideas","title":"Assessment Ideas","text":""},{"location":"teaching-guide/#quizzes","title":"Quizzes","text":"<ul> <li>\"What parameter would you use to get weather in Spanish?\"</li> <li>\"How do you check if an error occurred in a <code>fetch-my-weather</code> request?\"</li> <li>\"What is the difference between <code>units='m'</code> and <code>units='u'</code>?\"</li> </ul>"},{"location":"teaching-guide/#coding-challenges","title":"Coding Challenges","text":"<ul> <li>Create a function that returns just the temperature from a weather report</li> <li>Build a program that finds the coldest city from a list of cities</li> <li>Create a weekly forecast display that uses formatting to improve readability</li> </ul>"},{"location":"teaching-guide/#projects","title":"Projects","text":"<ul> <li>Weather logging application that records temperatures over time</li> <li>\"Weather around the world\" dashboard</li> <li>Command-line weather utility with various options</li> </ul>"},{"location":"teaching-guide/#ready-to-use-mini-projects","title":"Ready-to-Use Mini-Projects","text":"<p>We've created a collection of structured mini-projects that are ready to use in your classroom. These projects range from beginner to advanced levels and provide hands-on experience with the <code>fetch-my-weather</code> package.</p> <p>Check the <code>docs/mini-projects/</code> directory for a complete set of projects including:</p>"},{"location":"teaching-guide/#beginner-level_1","title":"Beginner Level","text":"<ul> <li>Personal Weather Dashboard - Create a simple console-based weather display</li> <li>Multi-City Weather Checker - Compare weather across multiple cities</li> <li>Weather Image Saver - Save weather data as PNG images</li> </ul>"},{"location":"teaching-guide/#intermediate-level_1","title":"Intermediate Level","text":"<ul> <li>Weather Mood Recommender - Get activity suggestions based on current weather</li> <li>Weekly Weather Forecast Tracker - Track and compare forecasts with actual weather</li> <li>Weather-based Wallpaper Changer - Automatically change desktop wallpaper based on weather</li> </ul>"},{"location":"teaching-guide/#advanced-level_1","title":"Advanced Level","text":"<ul> <li>Weather Notification System - Send alerts when specific weather conditions occur</li> <li>Weather Data Logger and Analyzer - Track and analyze weather data with visualizations</li> <li>Weather-Based Home Automation - Control smart home devices based on weather conditions</li> <li>Weather-based Game World Generator - Create a game that adapts to real-world weather</li> </ul> <p>Each project includes a detailed description, code samples, and extension ideas for further learning.</p>"},{"location":"teaching-guide/#common-student-questions-and-answers","title":"Common Student Questions and Answers","text":"<p>Q: Why doesn't <code>fetch-my-weather</code> raise exceptions like other libraries? A: It's designed to be beginner-friendly. Checking if a string starts with \"Error:\" is simpler than try/except blocks for beginners.</p> <p>Q: How can I extract specific data (like temperature) from the text output? A: You can use string operations like <code>split()</code> and regular expressions. This is intentionally part of the learning process!</p> <p>Q: Is there a limit to how many requests I can make? A: The underlying weather service may have rate limits. That's why <code>fetch-my-weather</code> includes caching to minimize requests. This is a good opportunity to discuss API etiquette.</p> <p>Q: Why use this instead of a more advanced weather API? A: <code>fetch-my-weather</code> is specifically designed for learning. It requires no API keys, has minimal setup, and provides a gentle introduction to API concepts.</p>"},{"location":"teaching-guide/#additional-resources","title":"Additional Resources","text":""},{"location":"teaching-guide/#supporting-materials","title":"Supporting Materials","text":"<ul> <li>Weather-related data sets for comparison exercises</li> <li>Sample functions for parsing weather text into structured data</li> <li>Example integration with plotting libraries</li> </ul>"},{"location":"teaching-guide/#extension-topics","title":"Extension Topics","text":"<ul> <li>Web scraping vs. API usage</li> <li>JSON APIs and data formats</li> <li>API authentication methods</li> <li>Rate limiting and responsible API usage</li> <li>Creating wrappers around existing packages</li> </ul> <p>This guide is meant to be flexible. Adapt it to your specific teaching context, student level, and course objectives. The <code>fetch-my-weather</code> package is intentionally simple but contains enough depth to support multiple lessons and projects of increasing complexity.</p>"},{"location":"technical-doc/","title":"Technical Documentation for fetch-my-weather","text":"<p>This document provides technical details about the implementation of the <code>fetch-my-weather</code> package. It's intended for developers who want to understand the internal workings of the package or who might want to contribute to its development.</p>"},{"location":"technical-doc/#architecture-overview","title":"Architecture Overview","text":"<p><code>fetch-my-weather</code> is intentionally designed with a simple, structured architecture consisting of public functions, Pydantic models, and a few private helper functions.</p>"},{"location":"technical-doc/#file-structure","title":"File Structure","text":"<pre><code>src/fetch_my_weather/\n\u251c\u2500\u2500 __init__.py      # Exports public API and models\n\u251c\u2500\u2500 core.py          # Core implementation\n\u2514\u2500\u2500 models.py        # Pydantic data models\n</code></pre>"},{"location":"technical-doc/#module-layout","title":"Module Layout","text":"<ul> <li>init.py: Exports the public API functions, models, and package metadata</li> <li>core.py: Contains all implementation code, including public API functions and private helper functions</li> <li>models.py: Contains Pydantic models that represent the structure of weather data</li> </ul>"},{"location":"technical-doc/#data-flow","title":"Data Flow","text":"<p>The basic flow of data through the package is:</p> <ol> <li>User calls <code>get_weather()</code> with parameters</li> <li>Parameters are validated</li> <li>If mock mode is enabled, mock data is returned</li> <li>URL is constructed using <code>_build_url()</code></li> <li>Cache is checked using <code>_get_from_cache()</code></li> <li>If data is not in cache, HTTP request is made</li> <li>Response is processed</li> <li>JSON responses are parsed and converted to Pydantic models</li> <li>Text responses are returned as strings</li> <li>PNG responses are returned as bytes</li> <li>Response is stored in cache using <code>_add_to_cache()</code></li> <li>Data is returned to the user</li> </ol> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 get_weather \u251c\u2500\u2500\u2500\u25ba\u2502   _build_url  \u251c\u2500\u2500\u2500\u25ba\u2502 Cache Check \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                                \u2502\n                                                \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Return Data \u2502\u25c4\u2500\u2500\u2500\u2524 _add_to_cache \u2502\u25c4\u2500\u2500\u2500\u2524 HTTP Request\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"technical-doc/#key-components","title":"Key Components","text":""},{"location":"technical-doc/#1-url-construction","title":"1. URL Construction","text":"<p>The <code>_build_url()</code> function handles the complex logic of constructing proper URLs for the weather service. It takes into account:</p> <ul> <li>Location specification</li> <li>Option formatting</li> <li>Output format (JSON, raw_json, text, PNG)</li> <li>Moon phase requests</li> <li>Language settings</li> </ul> <p>This function is critical because the weather service has different URL formats depending on the type of request.</p>"},{"location":"technical-doc/#2-pydantic-models","title":"2. Pydantic Models","text":"<p>The package uses Pydantic models to provide structured, type-safe access to JSON weather data:</p> <ul> <li><code>WeatherResponse</code>: Top-level model representing the complete API response</li> <li><code>CurrentCondition</code>: Weather conditions at the current time</li> <li><code>NearestArea</code>: Location information about the requested area</li> <li><code>DailyForecast</code>: Weather forecast for a specific day </li> <li><code>HourlyForecast</code>: Weather forecast for a specific hour</li> <li><code>Astronomy</code>: Sunrise, sunset, and moon phase data</li> </ul> <p>These models provide validation, type hints, and structured access to the data.</p>"},{"location":"technical-doc/#3-caching-system","title":"3. Caching System","text":"<p>The caching system consists of:</p> <ul> <li>A module-level dictionary <code>_cache</code> that stores responses</li> <li><code>_get_from_cache()</code> function to retrieve cached data</li> <li><code>_add_to_cache()</code> function to store new data</li> <li>Cache duration setting that controls expiration</li> <li>Public <code>clear_cache()</code> function to manually clear the cache</li> </ul> <p>The cache uses URLs as keys and stores tuples of <code>(timestamp, data)</code> as values. This allows for time-based expiration of cache entries.</p>"},{"location":"technical-doc/#4-mock-data-system","title":"4. Mock Data System","text":"<p>The mock data system allows for development and testing without making real API calls:</p> <ul> <li>A module-level flag <code>_USE_MOCK_DATA</code> to enable/disable mock mode</li> <li>Mock data for all three formats (JSON, text, PNG)</li> <li>Public <code>set_mock_mode()</code> function to control mock mode</li> <li>Per-request control with the <code>use_mock</code> parameter</li> </ul> <p>Mock data follows the same structure as real API responses, ensuring that code will work the same with both.</p>"},{"location":"technical-doc/#5-http-request-handling","title":"5. HTTP Request Handling","text":"<p>HTTP requests are made using the <code>requests</code> library. This section of the code:</p> <ul> <li>Sets appropriate headers (User-Agent)</li> <li>Makes the GET request with timeout</li> <li>Processes the response based on format (JSON, text, PNG)</li> <li>Converts JSON responses to Pydantic models</li> <li>Handles various error conditions</li> </ul>"},{"location":"technical-doc/#6-error-handling","title":"6. Error Handling","text":"<p>The package uses a consistent approach to error handling:</p> <ul> <li>No exceptions are raised to the user</li> <li>All errors are caught and converted to descriptive error messages</li> <li>Error messages are returned as strings that start with \"Error:\"</li> <li>HTTP errors include status codes</li> <li>Network errors include details about the failure</li> <li>JSON parsing errors include information about the validation failure</li> </ul>"},{"location":"technical-doc/#implementation-details","title":"Implementation Details","text":""},{"location":"technical-doc/#in-memory-cache","title":"In-memory Cache","text":"<p>The cache is implemented as a simple in-memory dictionary. This approach was chosen for simplicity and educational value. It means:</p> <ul> <li>Cache is not persistent across program restarts</li> <li>Cache is not shared between different processes</li> <li>Cache size is not explicitly limited (could grow large with many requests)</li> </ul> <pre><code># Format: { \"url\": (timestamp, data) }\n_cache = {}\n</code></pre>"},{"location":"technical-doc/#error-return-pattern","title":"Error Return Pattern","text":"<p>Instead of using exceptions, the package returns error information using a pattern recognition approach:</p> <pre><code># To return an error\nreturn f\"Error: {error_message}\"\n\n# To check for errors\nif isinstance(result, str) and result.startswith(\"Error:\"):\n    # Handle error\nelse:\n    # Process valid result\n</code></pre> <p>This pattern was chosen to make error handling more accessible to beginners.</p>"},{"location":"technical-doc/#format-selection-and-response-processing","title":"Format Selection and Response Processing","text":"<p>The package uses the <code>format</code> parameter to determine how to process the response:</p> <pre><code>if format == \"png\" or is_png:\n    data = response.content  # Return raw bytes for images\nelif format == \"raw_json\":\n    data = response.text\n    json_data = json.loads(data)\n    return json_data  # Return raw Python dictionary\nelif format == \"json\":\n    data = response.text\n    json_data = json.loads(data)\n    weather_response = WeatherResponse.parse_obj(json_data)  # Convert to Pydantic model\n    return weather_response\nelse:\n    data = response.text     # Return decoded text\n</code></pre> <p>The older <code>is_png</code> parameter is still supported for backward compatibility.</p>"},{"location":"technical-doc/#performance-considerations","title":"Performance Considerations","text":""},{"location":"technical-doc/#network-efficiency","title":"Network Efficiency","text":"<p>The built-in caching mechanism is designed to reduce network requests for identical queries, which: - Improves response times for repeated requests - Reduces load on the weather service - Helps avoid rate limiting</p>"},{"location":"technical-doc/#memory-usage","title":"Memory Usage","text":"<p>The in-memory cache can potentially consume significant memory if many different locations are queried and cached. Consider:</p> <ul> <li>Cache sizes are proportional to the response size (which can vary)</li> <li>No automatic pruning of old entries (only expiration-based removal)</li> <li>No size-based eviction policy</li> </ul>"},{"location":"technical-doc/#testing","title":"Testing","text":"<p>The package includes unit tests that focus on:</p> <ol> <li>URL construction</li> <li>Cache functionality</li> <li>Response handling</li> <li>Error handling</li> </ol> <p>Tests use mocking to avoid making actual network requests, ensuring tests are fast and reliable.</p>"},{"location":"technical-doc/#extensibility","title":"Extensibility","text":"<p>The package was designed with teaching in mind, but it also provides good extensibility:</p> <ol> <li>Data Models: The Pydantic models can be extended or customized</li> <li>Mock Data: Mock data can be modified for different testing scenarios</li> <li>Additional Weather Services: Support could be added for other weather APIs</li> <li>Advanced Caching: The caching system could be enhanced with persistence</li> <li>Additional Output Formats: New formats could be added beyond JSON, text, and PNG</li> </ol>"},{"location":"technical-doc/#dependencies","title":"Dependencies","text":"<p>The package has two external dependencies:</p> <ol> <li>requests: Used for making HTTP requests to the weather service</li> <li>Chosen for its simplicity and widespread use</li> <li> <p>Well-maintained and reliable</p> </li> <li> <p>pydantic: Used for data validation and parsing</p> </li> <li>Provides type safety and validation</li> <li>Makes JSON data easier to work with</li> <li>Excellent integration with IDEs for autocompletion</li> </ol> <p>Both dependencies are widely used and well-maintained, minimizing potential issues.</p>"},{"location":"user-guide/","title":"fetch-my-weather User Guide","text":"<p>Welcome to <code>fetch-my-weather</code>, a beginner-friendly Python package for accessing weather data! This guide will walk you through installation, basic usage, and advanced features.</p>"},{"location":"user-guide/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Installation</li> <li>Quick Start</li> <li>Core Features</li> <li>Getting Current Weather</li> <li>Weather for a Specific Location</li> <li>Different Weather Views</li> <li>Changing Units</li> <li>Language Support</li> <li>Data Formats</li> <li>Moon Phases</li> <li>Weather Images</li> <li>Working with JSON &amp; Models</li> <li>Caching</li> <li>Mock Mode</li> <li>Error Handling</li> <li>Advanced Usage</li> <li>Common Issues</li> <li>Educational Notes</li> </ol>"},{"location":"user-guide/#installation","title":"Installation","text":"<p>Installing the package is simple using pip:</p> <pre><code>pip install fetch-my-weather\n</code></pre>"},{"location":"user-guide/#quick-start","title":"Quick Start","text":"<p>Here's a basic example to get you started:</p> <pre><code>import fetch_my_weather\n\n# Get current location weather as a structured model (default)\nweather = fetch_my_weather.get_weather()\nprint(f\"Temperature: {weather.current_condition[0].temp_C}\u00b0C\")\nprint(f\"Condition: {weather.current_condition[0].weatherDesc[0].value}\")\n\n# Get weather for a specific city as plain text\nparis_weather = fetch_my_weather.get_weather(location=\"Paris\", format=\"text\")\nprint(paris_weather)\n</code></pre>"},{"location":"user-guide/#core-features","title":"Core Features","text":""},{"location":"user-guide/#getting-current-weather","title":"Getting Current Weather","text":"<p>When called without a location, <code>fetch_my_weather</code> detects your location based on your IP address:</p> <pre><code>import fetch_my_weather\n\n# Get weather for current location (returns a Pydantic model by default)\ncurrent_weather = fetch_my_weather.get_weather()\n\n# Access structured data\ntemperature = current_weather.current_condition[0].temp_C\ncondition = current_weather.current_condition[0].weatherDesc[0].value\nprint(f\"It's {condition} and {temperature}\u00b0C\")\n</code></pre>"},{"location":"user-guide/#weather-for-a-specific-location","title":"Weather for a Specific Location","text":"<p>You can request weather for many types of locations:</p> <pre><code># City name\nnyc_weather = fetch_my_weather.get_weather(location=\"New York\")\n\n# Airport code\nlax_weather = fetch_my_weather.get_weather(location=\"LAX\")\n\n# Geographic coordinates (latitude,longitude)\nparis_weather = fetch_my_weather.get_weather(location=\"48.8567,2.3508\")\n\n# Special locations\nmountain_weather = fetch_my_weather.get_weather(location=\"~Mount Everest\")\n</code></pre>"},{"location":"user-guide/#different-weather-views","title":"Different Weather Views","text":"<p>The package supports different view options:</p> <pre><code># Full weather report (default)\nfull_weather = fetch_my_weather.get_weather(location=\"London\")\n\n# Current weather only (no forecast)\ncurrent_only = fetch_my_weather.get_weather(location=\"London\", view_options=\"0\")\n\n# One-day forecast \none_day = fetch_my_weather.get_weather(location=\"London\", view_options=\"1\")\n\n# Two-day forecast\ntwo_day = fetch_my_weather.get_weather(location=\"London\", view_options=\"2\")\n\n# Narrow version (good for smaller terminals)\nnarrow = fetch_my_weather.get_weather(location=\"London\", view_options=\"n\")\n\n# Quiet version (no location in header)\nquiet = fetch_my_weather.get_weather(location=\"London\", view_options=\"q\")\n\n# You can combine options\nnarrow_and_quiet = fetch_my_weather.get_weather(location=\"London\", view_options=\"nq\")\nnarrow_quiet_one_day = fetch_my_weather.get_weather(location=\"London\", view_options=\"nq1\")\n</code></pre>"},{"location":"user-guide/#changing-units","title":"Changing Units","text":"<p>Choose between metric (default) and U.S. customary units:</p> <pre><code># Metric units (default)\nmetric = fetch_my_weather.get_weather(location=\"Tokyo\")\n\n# US/Imperial units\nimperial = fetch_my_weather.get_weather(location=\"Tokyo\", units=\"u\")\n\n# Metric with wind in m/s instead of km/h\nmetric_ms = fetch_my_weather.get_weather(location=\"Tokyo\", units=\"M\")\n</code></pre>"},{"location":"user-guide/#language-support","title":"Language Support","text":"<p>Weather reports are available in many languages:</p> <pre><code># Spanish\nspanish = fetch_my_weather.get_weather(location=\"Madrid\", lang=\"es\")\n\n# French\nfrench = fetch_my_weather.get_weather(location=\"Paris\", lang=\"fr\")\n\n# German\ngerman = fetch_my_weather.get_weather(location=\"Berlin\", lang=\"de\")\n\n# Japanese\njapanese = fetch_my_weather.get_weather(location=\"Tokyo\", lang=\"ja\")\n\n# Russian\nrussian = fetch_my_weather.get_weather(location=\"Moscow\", lang=\"ru\")\n\n# Chinese (Simplified)\nchinese = fetch_my_weather.get_weather(location=\"Beijing\", lang=\"zh-cn\")\n</code></pre>"},{"location":"user-guide/#data-formats","title":"Data Formats","text":"<p>The package supports multiple data formats to suit different needs:</p> <pre><code># JSON format (default) - returns a Pydantic model for structured data access\njson_weather = fetch_my_weather.get_weather(location=\"London\")\n# Access data with type safety and autocompletion\ntemp = json_weather.current_condition[0].temp_C \n\n# Raw JSON format - returns a Python dictionary\nraw_weather = fetch_my_weather.get_weather(location=\"London\", format=\"raw_json\")\n# Access data using dictionary syntax\ntemp = raw_weather[\"current_condition\"][0][\"temp_C\"]\ncondition = raw_weather[\"current_condition\"][0][\"weatherDesc\"][0][\"value\"]\n\n# Text format - returns plain text with ASCII art (for direct display)\ntext_weather = fetch_my_weather.get_weather(location=\"Paris\", format=\"text\")\nprint(text_weather)\n\n# PNG format - returns image bytes\npng_weather = fetch_my_weather.get_weather(location=\"Tokyo\", format=\"png\")\nwith open(\"weather.png\", \"wb\") as f:\n    f.write(png_weather)\n</code></pre>"},{"location":"user-guide/#moon-phases","title":"Moon Phases","text":"<p>You can also get information about moon phases:</p> <pre><code># Current moon phase\nmoon = fetch_my_weather.get_weather(is_moon=True)\n\n# Moon phase for a specific date\nfuture_moon = fetch_my_weather.get_weather(is_moon=True, moon_date=\"2025-12-25\")\n\n# Moon phase with location hint (useful for timing)\nus_moon = fetch_my_weather.get_weather(is_moon=True, moon_location_hint=\",+US\")\nparis_moon = fetch_my_weather.get_weather(is_moon=True, moon_location_hint=\",+Paris\")\n</code></pre>"},{"location":"user-guide/#weather-images","title":"Weather Images","text":"<p>Weather data can also be returned as PNG images:</p> <pre><code># Get weather as PNG image using format parameter (returns bytes)\nlondon_png = fetch_my_weather.get_weather(location=\"London\", format=\"png\")\n\n# Save the PNG to a file\nwith open(\"london_weather.png\", \"wb\") as f:\n    f.write(london_png)\n\n# Get transparent PNG \ntransparent_png = fetch_my_weather.get_weather(\n    location=\"London\", \n    format=\"png\", \n    png_options=\"t\"\n)\n\n# Get PNG with padding\npadded_png = fetch_my_weather.get_weather(\n    location=\"London\", \n    format=\"png\", \n    png_options=\"p\"\n)\n\n# Combine PNG options\ntransparent_padded = fetch_my_weather.get_weather(\n    location=\"London\", \n    format=\"png\", \n    png_options=\"tp\"\n)\n\n# Legacy method (deprecated but still supported)\nlegacy_png = fetch_my_weather.get_weather(location=\"London\", is_png=True)\n</code></pre>"},{"location":"user-guide/#working-with-json-models","title":"Working with JSON &amp; Models","text":"<p>When using the default JSON format, the package returns data as Pydantic models that provide type safety and structure:</p> <pre><code>from fetch_my_weather import WeatherResponse\n\n# Get weather data as a model (this is the default)\nweather = fetch_my_weather.get_weather(location=\"London\")\n\n# Using type hints for better IDE support\nweather_typed: WeatherResponse = fetch_my_weather.get_weather(location=\"London\")\n\n# Access current conditions\ncurrent = weather.current_condition[0]\nprint(f\"Temperature: {current.temp_C}\u00b0C\")\nprint(f\"Feels like: {current.FeelsLikeC}\u00b0C\")\nprint(f\"Condition: {current.weatherDesc[0].value}\")\nprint(f\"Humidity: {current.humidity}%\")\nprint(f\"Wind: {current.windspeedKmph} km/h, {current.winddir16Point}\")\n\n# Access location information\nlocation = weather.nearest_area[0]\nprint(f\"Location: {location.areaName[0].value}, {location.country[0].value}\")\nprint(f\"Region: {location.region[0].value}\")\nprint(f\"Coordinates: {location.latitude}, {location.longitude}\")\n\n# Access forecast data\nfor day in weather.weather:\n    print(f\"Date: {day.date}\")\n    print(f\"Max/Min: {day.maxtempC}\u00b0C/{day.mintempC}\u00b0C\")\n\n    # Access astronomy data\n    astronomy = day.astronomy[0]\n    print(f\"Sunrise: {astronomy.sunrise}, Sunset: {astronomy.sunset}\")\n\n    # Access hourly forecast (just first entry as example)\n    hour = day.hourly[0]\n    print(f\"Time: {hour.time}, Temp: {hour.tempC}\u00b0C\")\n</code></pre>"},{"location":"user-guide/#caching","title":"Caching","text":"<p>To reduce unnecessary network requests, <code>fetch_my_weather</code> caches responses for 10 minutes by default. You can control this behavior:</p> <pre><code>import fetch_my_weather\n\n# Set cache duration to 30 minutes (1800 seconds)\nfetch_my_weather.set_cache_duration(1800)\n\n# Disable caching completely\nfetch_my_weather.set_cache_duration(0)\n\n# Clear the current cache\nfetch_my_weather.clear_cache()\n</code></pre>"},{"location":"user-guide/#mock-mode","title":"Mock Mode","text":"<p>For development and testing without hitting API rate limits, the package includes a mock mode:</p> <pre><code>import fetch_my_weather\n\n# Enable mock mode globally\nfetch_my_weather.set_mock_mode(True)\n\n# Now all requests will use mock data instead of real API calls\nmock_weather = fetch_my_weather.get_weather(location=\"London\")\nprint(f\"Temperature: {mock_weather.current_condition[0].temp_C}\u00b0C\")\n\n# Use mock mode for a single request\nreal_weather = fetch_my_weather.get_weather(location=\"Paris\", use_mock=False)\nmock_weather = fetch_my_weather.get_weather(location=\"Berlin\", use_mock=True)\n\n# Disable mock mode\nfetch_my_weather.set_mock_mode(False)\n</code></pre> <p>Mock mode provides realistic sample data that matches the structure of real API responses, making it ideal for:</p> <ul> <li>Development without internet connection</li> <li>Avoiding rate limits during testing</li> <li>Creating reproducible examples</li> <li>Writing unit tests</li> </ul>"},{"location":"user-guide/#error-handling","title":"Error Handling","text":"<p>One of the key features of <code>fetch_my_weather</code> is its beginner-friendly error handling. Instead of raising exceptions, it returns error messages as strings:</p> <pre><code>import fetch_my_weather\n\n# Try to get weather for a location that might not exist\nresult = fetch_my_weather.get_weather(location=\"NonExistentPlace12345\")\n\n# Check if we got an error message\nif isinstance(result, str) and result.startswith(\"Error:\"):\n    print(f\"Oops! Something went wrong: {result}\")\nelif isinstance(result, fetch_my_weather.WeatherResponse):\n    print(f\"Weather data received for {result.nearest_area[0].areaName[0].value}\")\nelse:\n    print(\"Weather data received (non-JSON format)\")\n</code></pre>"},{"location":"user-guide/#advanced-usage","title":"Advanced Usage","text":""},{"location":"user-guide/#setting-a-custom-user-agent","title":"Setting a Custom User Agent","text":"<pre><code># Set a custom user agent (helpful if you're building an app)\nfetch_my_weather.set_user_agent(\"MyWeatherApp/1.0\")\n</code></pre>"},{"location":"user-guide/#combining-multiple-options","title":"Combining Multiple Options","text":"<p>You can combine different parameters to customize your request:</p> <pre><code># Get one-day forecast for Paris in French with US units in narrow format\nparis_custom = fetch_my_weather.get_weather(\n    location=\"Paris\",\n    units=\"u\",\n    view_options=\"1n\",\n    lang=\"fr\"\n)\n</code></pre>"},{"location":"user-guide/#common-issues","title":"Common Issues","text":""},{"location":"user-guide/#network-problems","title":"Network Problems","text":"<p>If you have connectivity issues, <code>fetch_my_weather</code> will return an error message string:</p> <pre><code>Error: Could not connect to http://wttr.in/London. Check network connection.\n</code></pre> <p>In your code, always check if the result starts with \"Error:\" before trying to use it.</p>"},{"location":"user-guide/#location-not-found","title":"Location Not Found","text":"<p>If a location cannot be found, you'll receive an error message. Try using more specific location information like coordinates or airport codes.</p>"},{"location":"user-guide/#rate-limiting","title":"Rate Limiting","text":"<p>The weather service may have rate limits. By default, <code>fetch_my_weather</code> includes caching to reduce requests, but if you make too many unique requests too quickly, you might get error messages.</p>"},{"location":"user-guide/#educational-notes","title":"Educational Notes","text":"<p>The <code>fetch_my_weather</code> package is designed with education in mind:</p> <ol> <li> <p>Simplicity Over Complexity: The API is intentionally kept simple with a single main function.</p> </li> <li> <p>Readable Error Messages: Errors are returned as readable strings rather than exceptions, making it easier for beginners.</p> </li> <li> <p>Built-in Caching: The caching system demonstrates how to avoid unnecessary network requests.</p> </li> <li> <p>Example-Rich Documentation: Each feature is demonstrated with clear examples.</p> </li> <li> <p>Minimal Dependencies: The package only requires the <code>requests</code> library, keeping it lightweight.</p> </li> </ol> <p>This package is ideal for: - Introducing students to working with APIs - Teaching basic network request concepts - Demonstrating data retrieval and display - Learning about caching and performance optimization</p>"},{"location":"user-guide/#mini-projects","title":"Mini-Projects","text":"<p>To help you get started with practical applications, we've included a collection of mini-projects in the <code>docs/mini-projects/</code> directory. These are organized by difficulty level:</p>"},{"location":"user-guide/#beginner-projects","title":"Beginner Projects","text":"<ul> <li>Personal Weather Dashboard: Simple program showing weather for your location</li> <li>Multi-City Weather Checker: Compare weather across multiple cities</li> <li>Weather Image Saver: Save weather data as PNG images</li> </ul>"},{"location":"user-guide/#intermediate-projects","title":"Intermediate Projects","text":"<ul> <li>Weather Mood Recommender: Get activity suggestions based on current weather</li> <li>Weekly Weather Forecast Tracker: Track and compare forecasts with actual weather</li> <li>Weather-based Wallpaper Changer: Change your desktop wallpaper based on weather</li> </ul>"},{"location":"user-guide/#advanced-projects","title":"Advanced Projects","text":"<ul> <li>Weather Notification System: Get alerts for specific weather conditions</li> <li>Weather Data Logger and Analyzer: Track and visualize weather data over time</li> <li>Weather-Based Home Automation: Control smart home devices based on weather</li> <li>Weather-based Game World Generator: Create games that adapt to real-world weather</li> </ul> <p>Each project includes full code samples and instructions. They're perfect for learning or teaching Python with real-world applications.</p> <p>We hope you enjoy using <code>fetch_my_weather</code>! If you have any questions or suggestions, please feel free to open an issue on our GitHub repository.</p>"},{"location":"mini-projects/","title":"Mini-Projects for fetch-my-weather","text":"<p>This directory contains project ideas using the <code>fetch-my-weather</code> package, ranging from beginner to advanced level. These projects are designed to be educational, fun, and practical while teaching important programming concepts.</p>"},{"location":"mini-projects/#project-categories","title":"Project Categories","text":"<p>Projects are organized by difficulty level:</p>"},{"location":"mini-projects/#beginner-projects","title":"Beginner Projects","text":"<p>Perfect for those just getting started with Python and the fetch-my-weather package:</p> <ul> <li>Personal Weather Dashboard - Create a simple program that shows the weather for your location when you start your computer</li> <li>Multi-City Weather Checker - Compare weather across multiple cities</li> <li>Weather Image Saver - Save weather data as PNG images</li> </ul>"},{"location":"mini-projects/#intermediate-projects","title":"Intermediate Projects","text":"<p>For those with some Python experience looking to build more complex applications:</p> <ul> <li>Weather Mood Recommender - Get activity suggestions based on current weather</li> <li>Weekly Weather Forecast Tracker - Track and compare forecasts with actual weather</li> <li>Weather-based Wallpaper Changer - Automatically change desktop wallpaper based on current weather</li> </ul>"},{"location":"mini-projects/#advanced-projects","title":"Advanced Projects","text":"<p>For experienced developers who want to build more sophisticated applications:</p> <ul> <li>Weather Notification System - Send notifications when specific weather conditions occur</li> <li>Weather Data Logger and Analyzer - Track and analyze weather data over time with visualizations</li> <li>Weather-Based Home Automation - Control smart home devices based on weather conditions</li> <li>Weather-based Game World Generator - Create a game that generates environments based on real-world weather</li> </ul>"},{"location":"mini-projects/#getting-started","title":"Getting Started","text":"<p>To use these projects:</p> <ol> <li> <p>Make sure you have installed the fetch-my-weather package:    <pre><code>pip install fetch-my-weather\n</code></pre></p> </li> <li> <p>Choose a project based on your skill level and interests</p> </li> <li> <p>Follow the instructions in the project file</p> </li> <li> <p>Experiment with the extensions suggested at the end of each project to make it your own!</p> </li> </ol>"},{"location":"mini-projects/#contributing","title":"Contributing","text":"<p>Feel free to submit your own project ideas or improvements to the existing ones by creating a pull request!</p>"},{"location":"mini-projects/advanced/weather-data-logger-analyzer/","title":"Weather Data Logger and Analyzer","text":"<p>Description: Create a system that logs weather data over time and generates reports with statistics and trends.</p> <p>Skills practiced: - Data logging - File I/O with CSV - Data analysis - Visualization with matplotlib</p> <p>Sample code:</p> <pre><code>import fetch_my_weather\nimport csv\nimport os\nimport time\nfrom datetime import datetime, timedelta\nimport matplotlib.pyplot as plt\nimport re\n\nclass WeatherLogger:\n    def __init__(self, location=\"\", log_file=\"weather_log.csv\"):\n        self.location = location\n        self.log_file = log_file\n\n        # Create log file with header if it doesn't exist\n        if not os.path.exists(log_file):\n            with open(log_file, 'w', newline='') as csvfile:\n                writer = csv.writer(csvfile)\n                writer.writerow([\n                    'timestamp', 'location', 'temperature_c', \n                    'condition', 'humidity', 'wind_speed_kmh'\n                ])\n            print(f\"Created new log file: {log_file}\")\n\n    def extract_temperature(self, weather_text):\n        \"\"\"Extract temperature from weather text\"\"\"\n        match = re.search(r'(\\-?\\d+)\\s*\u00b0C', weather_text)\n        if match:\n            return int(match.group(1))\n        return None\n\n    def extract_condition(self, weather_text):\n        \"\"\"Extract weather condition from text\"\"\"\n        conditions = [\n            \"clear\", \"sunny\", \"partly cloudy\", \"cloudy\", \"overcast\",\n            \"rain\", \"light rain\", \"heavy rain\", \"showers\", \"thunderstorm\",\n            \"snow\", \"light snow\", \"heavy snow\", \"sleet\", \"hail\", \"fog\", \"mist\"\n        ]\n\n        weather_lower = weather_text.lower()\n        for condition in conditions:\n            if condition in weather_lower:\n                return condition\n        return \"unknown\"\n\n    def extract_humidity(self, weather_text):\n        \"\"\"Extract humidity percentage from text\"\"\"\n        match = re.search(r'humidity\\D+(\\d+)', weather_text.lower())\n        if match:\n            return int(match.group(1))\n        return None\n\n    def extract_wind_speed(self, weather_text):\n        \"\"\"Extract wind speed from text\"\"\"\n        match = re.search(r'(\\d+)\\s*km/h', weather_text)\n        if match:\n            return int(match.group(1))\n        return None\n\n    def log_current_weather(self):\n        \"\"\"Get current weather and log it to CSV\"\"\"\n        # Get current weather\n        weather = fetch_my_weather.get_weather(location=self.location, view_options=\"q\")\n\n        if isinstance(weather, str) and not weather.startswith(\"Error:\"):\n            # Extract data points\n            timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n            temperature = self.extract_temperature(weather)\n            condition = self.extract_condition(weather)\n            humidity = self.extract_humidity(weather)\n            wind_speed = self.extract_wind_speed(weather)\n\n            # Log to CSV\n            with open(self.log_file, 'a', newline='') as csvfile:\n                writer = csv.writer(csvfile)\n                writer.writerow([\n                    timestamp, self.location or \"current\", \n                    temperature, condition, humidity, wind_speed\n                ])\n\n            print(f\"Logged weather data: {temperature}\u00b0C, {condition}, \"\n                  f\"humidity: {humidity}%, wind: {wind_speed} km/h\")\n            return True\n        else:\n            print(f\"Error getting weather: {weather}\")\n            return False\n\n    def generate_daily_report(self, days=7):\n        \"\"\"Generate a report of the last X days of weather data\"\"\"\n        if not os.path.exists(self.log_file):\n            print(f\"Log file not found: {self.log_file}\")\n            return False\n\n        # Read the log file\n        timestamps = []\n        temperatures = []\n        conditions = {}\n\n        with open(self.log_file, 'r', newline='') as csvfile:\n            reader = csv.DictReader(csvfile)\n            for row in reader:\n                if row['temperature_c'] and row['timestamp']:\n                    # Convert timestamp to datetime\n                    timestamp = datetime.strptime(row['timestamp'], \"%Y-%m-%d %H:%M:%S\")\n\n                    # Only include data from the last X days\n                    if timestamp &gt;= (datetime.now() - timedelta(days=days)):\n                        timestamps.append(timestamp)\n                        temperatures.append(float(row['temperature_c']))\n\n                        # Count conditions\n                        condition = row['condition'] or \"unknown\"\n                        if condition in conditions:\n                            conditions[condition] += 1\n                        else:\n                            conditions[condition] = 1\n\n        if not timestamps:\n            print(\"No data available for the specified time period.\")\n            return False\n\n        # Generate temperature chart\n        plt.figure(figsize=(12, 6))\n        plt.plot(timestamps, temperatures, marker='o', linestyle='-')\n        plt.title(f\"Temperature over the last {days} days\")\n        plt.xlabel(\"Date\")\n        plt.ylabel(\"Temperature (\u00b0C)\")\n        plt.grid(True)\n        plt.xticks(rotation=45)\n        plt.tight_layout()\n\n        # Save the chart\n        chart_file = f\"temperature_chart_{datetime.now().strftime('%Y%m%d')}.png\"\n        plt.savefig(chart_file)\n        plt.close()\n\n        # Generate condition pie chart\n        plt.figure(figsize=(8, 8))\n        plt.pie(conditions.values(), labels=conditions.keys(), autopct='%1.1f%%')\n        plt.title(\"Weather Conditions Distribution\")\n        plt.tight_layout()\n\n        # Save the pie chart\n        pie_file = f\"conditions_chart_{datetime.now().strftime('%Y%m%d')}.png\"\n        plt.savefig(pie_file)\n        plt.close()\n\n        # Print statistics\n        avg_temp = sum(temperatures) / len(temperatures)\n        max_temp = max(temperatures)\n        min_temp = min(temperatures)\n\n        print(\"\\n=== Weather Report ===\")\n        print(f\"Period: Last {days} days\")\n        print(f\"Data points: {len(temperatures)}\")\n        print(f\"Average temperature: {avg_temp:.1f}\u00b0C\")\n        print(f\"Maximum temperature: {max_temp}\u00b0C\")\n        print(f\"Minimum temperature: {min_temp}\u00b0C\")\n        print(\"\\nWeather conditions:\")\n        for condition, count in sorted(conditions.items(), key=lambda x: x[1], reverse=True):\n            percentage = (count / len(temperatures)) * 100\n            print(f\"  {condition}: {count} ({percentage:.1f}%)\")\n\n        print(f\"\\nCharts saved as {chart_file} and {pie_file}\")\n        return True\n\ndef log_weather_periodically(location=\"\", interval_minutes=60, duration_hours=24):\n    \"\"\"Log weather at regular intervals for a specified duration\"\"\"\n    logger = WeatherLogger(location)\n    iterations = int((duration_hours * 60) / interval_minutes)\n\n    print(f\"Starting weather logging for {location or 'current location'}\")\n    print(f\"Interval: {interval_minutes} minutes\")\n    print(f\"Duration: {duration_hours} hours ({iterations} measurements)\")\n    print(\"Press Ctrl+C to stop logging early.\")\n\n    try:\n        for i in range(iterations):\n            print(f\"\\nLogging iteration {i+1}/{iterations}\")\n            logger.log_current_weather()\n\n            if i &lt; iterations - 1:  # Don't sleep after the last iteration\n                print(f\"Next log in {interval_minutes} minutes...\")\n                time.sleep(interval_minutes * 60)\n\n        print(\"\\nLogging complete. Generating report...\")\n        logger.generate_daily_report()\n\n    except KeyboardInterrupt:\n        print(\"\\nLogging stopped early by user.\")\n        print(\"Generating report with data collected so far...\")\n        logger.generate_daily_report()\n\n# Example usage\nif __name__ == \"__main__\":\n    location = input(\"Enter location (or press Enter for current location): \")\n    interval = int(input(\"Enter logging interval in minutes (default: 60): \") or \"60\")\n    duration = int(input(\"Enter logging duration in hours (default: 24): \") or \"24\")\n\n    log_weather_periodically(location, interval, duration)\n</code></pre> <p>Note: This project requires matplotlib for visualization (<code>pip install matplotlib</code>).</p> <p>Extensions: - Add more sophisticated data analysis (trends, correlations) - Create a web dashboard to display the data - Implement prediction models based on historical data</p>"},{"location":"mini-projects/advanced/weather-game-world-generator/","title":"Weather-based Game World Generator","text":"<p>Description: Create a game that generates different landscapes, challenges, and scenarios based on the real-world weather.</p> <p>Skills practiced: - Game development concepts - Creative coding - Environmental data integration - ASCII art generation</p> <p>Sample code:</p> <pre><code>import fetch_my_weather\nimport random\nimport time\nimport os\nimport re\nfrom datetime import datetime\n\nclass WeatherGame:\n    def __init__(self):\n        self.player = {\n            \"name\": \"Adventurer\",\n            \"health\": 100,\n            \"energy\": 100,\n            \"inventory\": [\"map\", \"water bottle\"],\n            \"position\": (0, 0)\n        }\n\n        self.current_weather = None\n        self.world_type = None\n        self.enemies = []\n        self.resources = []\n        self.weather_effects = []\n\n    def clear_screen(self):\n        \"\"\"Clear the terminal screen\"\"\"\n        os.system('cls' if os.name == 'nt' else 'clear')\n\n    def get_real_weather(self, location=\"\"):\n        \"\"\"Get real-world weather and set game environment\"\"\"\n        print(\"Connecting to weather service to generate your world...\")\n\n        weather_text = fetch_my_weather.get_weather(location=location, view_options=\"q\")\n\n        if isinstance(weather_text, str) and not weather_text.startswith(\"Error:\"):\n            # Extract key weather information\n            self.current_weather = self.parse_weather(weather_text)\n            print(f\"Weather data received: {self.current_weather['condition']}, {self.current_weather['temperature']}\u00b0C\")\n            return True\n        else:\n            print(f\"Error getting weather: {weather_text}\")\n            # Use default weather\n            self.current_weather = {\n                \"temperature\": 20,\n                \"condition\": \"clear\",\n                \"wind_speed\": 5,\n                \"humidity\": 60,\n                \"is_day\": True\n            }\n            print(\"Using default weather settings.\")\n            return False\n\n    def parse_weather(self, weather_text):\n        \"\"\"Parse weather text into game-relevant data\"\"\"\n        weather_lower = weather_text.lower()\n\n        # Extract temperature\n        temp_match = re.search(r'(\\-?\\d+)\\s*\u00b0C', weather_text)\n        temperature = int(temp_match.group(1)) if temp_match else 20\n\n        # Extract wind speed\n        wind_match = re.search(r'(\\d+)\\s*km/h', weather_text)\n        wind_speed = int(wind_match.group(1)) if wind_match else 5\n\n        # Extract humidity\n        humidity_match = re.search(r'humidity\\D+(\\d+)', weather_lower)\n        humidity = int(humidity_match.group(1)) if humidity_match else 60\n\n        # Determine time of day\n        is_day = True\n        if \"night\" in weather_lower or \"evening\" in weather_lower:\n            is_day = False\n\n        # Determine condition\n        condition = \"clear\"\n        if \"rain\" in weather_lower or \"shower\" in weather_lower:\n            condition = \"rainy\"\n        elif \"snow\" in weather_lower or \"blizzard\" in weather_lower:\n            condition = \"snowy\"\n        elif \"cloud\" in weather_lower or \"overcast\" in weather_lower:\n            condition = \"cloudy\"\n        elif \"fog\" in weather_lower or \"mist\" in weather_lower:\n            condition = \"foggy\"\n        elif \"storm\" in weather_lower or \"thunder\" in weather_lower:\n            condition = \"stormy\"\n\n        return {\n            \"temperature\": temperature,\n            \"condition\": condition,\n            \"wind_speed\": wind_speed,\n            \"humidity\": humidity,\n            \"is_day\": is_day\n        }\n\n    def generate_world(self):\n        \"\"\"Generate game world based on weather\"\"\"\n        weather = self.current_weather\n\n        # Determine world type based on weather\n        if weather[\"condition\"] == \"rainy\":\n            self.world_type = \"swamp\"\n            self.enemies = [\"frog warrior\", \"mud creature\", \"water elemental\"]\n            self.resources = [\"mushrooms\", \"water lilies\", \"rare herbs\"]\n            self.weather_effects = [\"reduced visibility\", \"slippery ground\", \"rising water\"]\n\n        elif weather[\"condition\"] == \"snowy\":\n            self.world_type = \"tundra\"\n            self.enemies = [\"frost wolf\", \"ice golem\", \"snow leopard\"]\n            self.resources = [\"ice crystals\", \"winter berries\", \"frozen minerals\"]\n            self.weather_effects = [\"cold damage\", \"limited stamina\", \"deep snow\"]\n\n        elif weather[\"condition\"] == \"cloudy\":\n            self.world_type = \"highlands\"\n            self.enemies = [\"mountain troll\", \"giant eagle\", \"rock creature\"]\n            self.resources = [\"alpine flowers\", \"bird eggs\", \"precious stones\"]\n            self.weather_effects = [\"occasional rain\", \"limited visibility\", \"gusty winds\"]\n\n        elif weather[\"condition\"] == \"foggy\":\n            self.world_type = \"haunted forest\"\n            self.enemies = [\"ghost\", \"shadow creature\", \"lost wanderer\"]\n            self.resources = [\"glowing mushrooms\", \"spirit essence\", \"strange fruits\"]\n            self.weather_effects = [\"disorientation\", \"invisibility\", \"whispers\"]\n\n        elif weather[\"condition\"] == \"stormy\":\n            self.world_type = \"storm islands\"\n            self.enemies = [\"lightning elemental\", \"storm drake\", \"cyclone spirit\"]\n            self.resources = [\"charged crystals\", \"rare metals\", \"storm flowers\"]\n            self.weather_effects = [\"lightning strikes\", \"heavy winds\", \"flooding\"]\n\n        else:  # clear/sunny\n            self.world_type = \"plains\"\n            self.enemies = [\"wild boar\", \"bandit\", \"hawk\"]\n            self.resources = [\"berries\", \"herbs\", \"wood\"]\n            self.weather_effects = [\"heat exhaustion\", \"clear visibility\", \"dry terrain\"]\n\n        # Temperature modifiers\n        if weather[\"temperature\"] &lt; 0:\n            self.world_type = f\"frozen {self.world_type}\"\n            self.weather_effects.append(\"freezing damage\")\n        elif weather[\"temperature\"] &gt; 30:\n            self.world_type = f\"scorching {self.world_type}\"\n            self.weather_effects.append(\"heat damage\")\n\n        # Day/night modifiers\n        if not weather[\"is_day\"]:\n            self.world_type = f\"nighttime {self.world_type}\"\n            self.enemies = [\"night \" + enemy for enemy in self.enemies]\n            self.weather_effects.append(\"darkness\")\n\n        print(f\"\\nGenerated world: {self.world_type.upper()}\")\n        print(f\"Based on: {weather['condition']} weather, {weather['temperature']}\u00b0C\")\n        print(f\"Special effects: {', '.join(self.weather_effects)}\")\n\n    def display_world(self):\n        \"\"\"Display ASCII art for the current world\"\"\"\n        if self.world_type is None:\n            return\n\n        # Simple ASCII art based on world type\n        art = \"\"\n\n        if \"swamp\" in self.world_type:\n            art = \"\"\"\n            ~~~~~~~  ^^^^^  ~~~~~~~\n             ~~ ~~  |.oo.|  ~~ ~~\n            ~ ~ ~ ~ |..&lt;.|~ ~ ~ ~\n            ~~~~~~~~~~~~~~~~~~~~~~~~~\n            \"\"\"\n        elif \"tundra\" in self.world_type:\n            art = \"\"\"\n               /\\\\      /\\\\   *  *\n              /  \\\\____/  \\\\    *  *\n             /            \\\\  *  *\n            /______________\\\\*******\n            \"\"\"\n        elif \"highlands\" in self.world_type:\n            art = \"\"\"\n                  /\\\\\n                 /  \\\\      /\\\\\n                /    \\\\    /  \\\\\n               /      \\\\__/    \\\\\n              /                \\\\\n             /__________________\\\\\n            \"\"\"\n        elif \"haunted forest\" in self.world_type:\n            art = \"\"\"\n              (  )   (   )  )\n                 ) (   )  (\n                (  (   )    )\n                   )  ) (\n              |\\\\   (  |   )\n              | )     \\\\|\n              |/      ||\n              /       |\\\\\n             |        | )\n             |        |/\n            \"\"\"\n        elif \"storm\" in self.world_type:\n            art = \"\"\"\n             \\\\    /    \\\\   /  ~~~~\n              \\\\  /      \\\\ /  ~/~~~\n            ~~~~~~~~~~~~~~~~~~~~~~~~\n               ~~~~~~~~~~~~~~~~\n                ~~~~~~~~~~\n            \"\"\"\n        else:  # plains\n            art = \"\"\"\n\n                        ^\n            \\\\           |\n             \\\\     ^    |    ^\n              \\\\    |    |    |\n               \\\\___|____|____|__\n            \"\"\"\n\n        print(art)\n\n    def get_random_encounter(self):\n        \"\"\"Generate a random encounter based on the world\"\"\"\n        encounter_type = random.choice([\"enemy\", \"resource\", \"effect\"])\n\n        if encounter_type == \"enemy\":\n            enemy = random.choice(self.enemies)\n            strength = random.randint(10, 30)\n            return {\n                \"type\": \"enemy\",\n                \"name\": enemy,\n                \"strength\": strength,\n                \"message\": f\"You encounter a {enemy} with strength {strength}!\"\n            }\n\n        elif encounter_type == \"resource\":\n            resource = random.choice(self.resources)\n            amount = random.randint(1, 5)\n            return {\n                \"type\": \"resource\",\n                \"name\": resource,\n                \"amount\": amount,\n                \"message\": f\"You found {amount} {resource}!\"\n            }\n\n        else:  # effect\n            effect = random.choice(self.weather_effects)\n            duration = random.randint(1, 3)\n            return {\n                \"type\": \"effect\",\n                \"name\": effect,\n                \"duration\": duration,\n                \"message\": f\"You experience {effect} for {duration} turns!\"\n            }\n\n    def handle_encounter(self, encounter):\n        \"\"\"Handle a random encounter\"\"\"\n        print(\"\\n\" + \"!\" * 40)\n        print(encounter[\"message\"])\n\n        if encounter[\"type\"] == \"enemy\":\n            print(\"Options: [F]ight, [R]un away\")\n            choice = input(\"&gt; \").strip().lower()\n\n            if choice == \"f\":\n                damage = random.randint(5, encounter[\"strength\"])\n                self.player[\"health\"] -= damage\n                print(f\"You fought the {encounter['name']} and took {damage} damage.\")\n\n                # Add item to inventory\n                if random.random() &lt; 0.3:  # 30% chance\n                    loot = f\"{encounter['name']} trophy\"\n                    self.player[\"inventory\"].append(loot)\n                    print(f\"You collected: {loot}\")\n            else:\n                energy_cost = random.randint(5, 15)\n                self.player[\"energy\"] -= energy_cost\n                print(f\"You ran away, using {energy_cost} energy.\")\n\n        elif encounter[\"type\"] == \"resource\":\n            print(\"Options: [C]ollect, [I]gnore\")\n            choice = input(\"&gt; \").strip().lower()\n\n            if choice == \"c\":\n                energy_cost = random.randint(1, 5)\n                self.player[\"energy\"] -= energy_cost\n                self.player[\"inventory\"].append(f\"{encounter['name']} x{encounter['amount']}\")\n                print(f\"You collected {encounter['amount']} {encounter['name']}, using {energy_cost} energy.\")\n            else:\n                print(\"You decided to ignore the resources.\")\n\n        elif encounter[\"type\"] == \"effect\":\n            print(\"A weather effect impacts you!\")\n            if \"damage\" in encounter[\"name\"]:\n                damage = random.randint(3, 10)\n                self.player[\"health\"] -= damage\n                print(f\"You took {damage} damage from {encounter['name']}.\")\n            elif \"stamina\" in encounter[\"name\"] or \"energy\" in encounter[\"name\"]:\n                energy_cost = random.randint(5, 15)\n                self.player[\"energy\"] -= energy_cost\n                print(f\"You lost {energy_cost} energy from {encounter['name']}.\")\n            else:\n                print(f\"The {encounter['name']} effect will persist for {encounter['duration']} turns.\")\n\n    def display_player_status(self):\n        \"\"\"Display player status\"\"\"\n        player = self.player\n        print(\"\\n\" + \"-\" * 40)\n        print(f\"Player: {player['name']}\")\n        print(f\"Health: {player['health']}/100\")\n        print(f\"Energy: {player['energy']}/100\")\n        print(\"Inventory:\")\n        for item in player['inventory']:\n            print(f\"  - {item}\")\n        print(\"-\" * 40)\n\n    def play_game(self):\n        \"\"\"Main game loop\"\"\"\n        self.clear_screen()\n        print(\"=== Weather Adventure Game ===\")\n        print(\"Your world will be generated based on the current weather!\")\n\n        # Get player name\n        self.player[\"name\"] = input(\"Enter your character name: \") or \"Adventurer\"\n\n        # Get location for weather\n        location = input(\"Enter location for weather (or press Enter for current location): \")\n\n        # Get real weather and generate world\n        self.get_real_weather(location)\n        self.generate_world()\n\n        # Game loop\n        turns = 1\n        while self.player[\"health\"] &gt; 0 and self.player[\"energy\"] &gt; 0 and turns &lt;= 10:\n            self.clear_screen()\n            print(f\"\\n=== Turn {turns} ===\")\n\n            # Display world\n            print(f\"You are in the {self.world_type}.\")\n            self.display_world()\n\n            # Display player status\n            self.display_player_status()\n\n            # Generate random encounter\n            encounter = self.get_random_encounter()\n            self.handle_encounter(encounter)\n\n            # Check if player is still alive\n            if self.player[\"health\"] &lt;= 0:\n                print(\"\\nYou have been defeated! Game over.\")\n                break\n            if self.player[\"energy\"] &lt;= 0:\n                print(\"\\nYou are exhausted and can't continue! Game over.\")\n                break\n\n            # Next turn\n            if turns &lt; 10:\n                print(\"\\nPress Enter to continue to the next turn...\")\n                input()\n\n            turns += 1\n\n        # Game end\n        if turns &gt; 10 and self.player[\"health\"] &gt; 0 and self.player[\"energy\"] &gt; 0:\n            print(\"\\nCongratulations! You survived the adventure!\")\n            print(f\"Final stats - Health: {self.player['health']}, Energy: {self.player['energy']}\")\n            print(f\"Items collected: {len(self.player['inventory'])} items\")\n\n# Run the game\nif __name__ == \"__main__\":\n    game = WeatherGame()\n    game.play_game()\n</code></pre> <p>Extensions: - Add more complex game mechanics (combat system, crafting, etc.) - Implement a graphical interface with pygame - Add more detailed weather effects on gameplay - Create a persistent world that evolves with the changing weather</p>"},{"location":"mini-projects/advanced/weather-home-automation/","title":"Weather-Based Home Automation Controller","text":"<p>Description: Build a system that controls smart home devices based on weather conditions.</p> <p>Skills practiced: - Integration with smart home APIs - Event-based programming - Configuration management - Scheduled tasks</p> <p>Concept code:</p> <pre><code>import fetch_my_weather\nimport json\nimport time\nimport requests\nfrom datetime import datetime\n\n# Note: This is conceptual code that would need to be adapted\n# to work with your specific smart home setup (Philips Hue, SmartThings, etc.)\n\nclass WeatherHomeAutomation:\n    def __init__(self, config_file=\"weather_home_config.json\"):\n        self.config_file = config_file\n        self.config = self.load_config()\n        self.last_check = None\n        self.current_weather = None\n\n    def load_config(self):\n        \"\"\"Load configuration or create default\"\"\"\n        try:\n            with open(self.config_file, \"r\") as f:\n                return json.load(f)\n        except:\n            # Default configuration\n            default_config = {\n                \"location\": \"\",  # Empty for auto-detect\n                \"check_interval_minutes\": 15,\n                \"smart_home_api\": {\n                    \"type\": \"hue\",  # hue, smartthings, etc.\n                    \"host\": \"192.168.1.100\",\n                    \"api_key\": \"your_api_key_here\",\n                },\n                \"rules\": [\n                    {\n                        \"condition\": \"rain\",\n                        \"actions\": [\n                            {\"device\": \"window\", \"command\": \"close\"},\n                            {\"device\": \"living_room_light\", \"command\": \"on\", \"brightness\": 80}\n                        ]\n                    },\n                    {\n                        \"condition\": \"temperature_below\",\n                        \"value\": 5,\n                        \"actions\": [\n                            {\"device\": \"thermostat\", \"command\": \"set_temp\", \"temperature\": 22}\n                        ]\n                    },\n                    {\n                        \"condition\": \"temperature_above\",\n                        \"value\": 25,\n                        \"actions\": [\n                            {\"device\": \"fan\", \"command\": \"on\", \"speed\": \"medium\"}\n                        ]\n                    },\n                    {\n                        \"condition\": \"sunny\",\n                        \"actions\": [\n                            {\"device\": \"blinds\", \"command\": \"close\"}\n                        ]\n                    },\n                    {\n                        \"condition\": \"wind_above\",\n                        \"value\": 40,\n                        \"actions\": [\n                            {\"device\": \"window\", \"command\": \"close\"},\n                            {\"device\": \"awning\", \"command\": \"retract\"}\n                        ]\n                    }\n                ]\n            }\n\n            # Save default config\n            with open(self.config_file, \"w\") as f:\n                json.dump(default_config, f, indent=2)\n\n            return default_config\n\n    def get_current_weather(self):\n        \"\"\"Get current weather data\"\"\"\n        location = self.config[\"location\"]\n        weather_text = fetch_my_weather.get_weather(location=location, view_options=\"q\")\n\n        if isinstance(weather_text, str) and not weather_text.startswith(\"Error:\"):\n            weather_data = {\n                \"timestamp\": datetime.now().isoformat(),\n                \"text\": weather_text,\n                \"conditions\": self.extract_conditions(weather_text)\n            }\n            self.current_weather = weather_data\n            return weather_data\n        else:\n            print(f\"Error getting weather: {weather_text}\")\n            return None\n\n    def extract_conditions(self, weather_text):\n        \"\"\"Extract conditions from weather text\"\"\"\n        weather_lower = weather_text.lower()\n\n        # Extract temperature\n        temp_match = re.search(r'(\\-?\\d+)\\s*\u00b0C', weather_text)\n        temperature = int(temp_match.group(1)) if temp_match else None\n\n        # Extract wind speed\n        wind_match = re.search(r'(\\d+)\\s*km/h', weather_text)\n        wind_speed = int(wind_match.group(1)) if wind_match else None\n\n        # Determine conditions\n        conditions = []\n\n        if \"rain\" in weather_lower or \"shower\" in weather_lower:\n            conditions.append(\"rain\")\n        if \"snow\" in weather_lower or \"blizzard\" in weather_lower:\n            conditions.append(\"snow\")\n        if \"sunny\" in weather_lower or \"clear\" in weather_lower:\n            conditions.append(\"sunny\")\n        if \"cloud\" in weather_lower or \"overcast\" in weather_lower:\n            conditions.append(\"cloudy\")\n        if \"fog\" in weather_lower or \"mist\" in weather_lower:\n            conditions.append(\"fog\")\n        if \"thunder\" in weather_lower or \"lightning\" in weather_lower:\n            conditions.append(\"thunderstorm\")\n\n        return {\n            \"temperature\": temperature,\n            \"wind_speed\": wind_speed,\n            \"conditions\": conditions\n        }\n\n    def check_rule(self, rule):\n        \"\"\"Check if a rule should be triggered based on current weather\"\"\"\n        if not self.current_weather:\n            return False\n\n        conditions = self.current_weather[\"conditions\"]\n\n        # Check different rule types\n        if rule[\"condition\"] == \"rain\" and \"rain\" in conditions[\"conditions\"]:\n            return True\n        elif rule[\"condition\"] == \"snow\" and \"snow\" in conditions[\"conditions\"]:\n            return True\n        elif rule[\"condition\"] == \"sunny\" and \"sunny\" in conditions[\"conditions\"]:\n            return True\n        elif rule[\"condition\"] == \"cloudy\" and \"cloudy\" in conditions[\"conditions\"]:\n            return True\n        elif rule[\"condition\"] == \"foggy\" and \"fog\" in conditions[\"conditions\"]:\n            return True\n        elif rule[\"condition\"] == \"temperature_below\" and conditions[\"temperature\"] is not None:\n            return conditions[\"temperature\"] &lt; rule[\"value\"]\n        elif rule[\"condition\"] == \"temperature_above\" and conditions[\"temperature\"] is not None:\n            return conditions[\"temperature\"] &gt; rule[\"value\"]\n        elif rule[\"condition\"] == \"wind_above\" and conditions[\"wind_speed\"] is not None:\n            return conditions[\"wind_speed\"] &gt; rule[\"value\"]\n\n        return False\n\n    def execute_action(self, action):\n        \"\"\"Execute a home automation action\"\"\"\n        # This would need to be implemented for your specific smart home system\n        print(f\"Executing action: {action}\")\n\n        api_config = self.config[\"smart_home_api\"]\n        api_type = api_config[\"type\"]\n\n        # Example for Philips Hue\n        if api_type == \"hue\":\n            if action[\"command\"] == \"on\":\n                self.hue_set_light(action[\"device\"], True, action.get(\"brightness\", 100))\n            elif action[\"command\"] == \"off\":\n                self.hue_set_light(action[\"device\"], False)\n\n        # Example for a generic API\n        elif api_type == \"generic\":\n            self.generic_api_call(action)\n\n    def hue_set_light(self, light_id, on, brightness=None):\n        \"\"\"Example function to control Philips Hue lights\"\"\"\n        api_config = self.config[\"smart_home_api\"]\n\n        # Construct URL for Hue API\n        url = f\"http://{api_config['host']}/api/{api_config['api_key']}/lights/{light_id}/state\"\n\n        # Prepare data\n        data = {\"on\": on}\n        if on and brightness is not None:\n            data[\"bri\"] = min(254, int(brightness * 2.54))  # Convert percentage to Hue brightness\n\n        # Make API call\n        try:\n            response = requests.put(url, json=data)\n            if response.status_code == 200:\n                print(f\"Successfully set light {light_id} to {on}, brightness: {brightness}\")\n            else:\n                print(f\"Error setting light: {response.text}\")\n        except Exception as e:\n            print(f\"Error calling Hue API: {e}\")\n\n    def generic_api_call(self, action):\n        \"\"\"Example function for a generic API call\"\"\"\n        # This is a placeholder that would need to be customized for your smart home system\n        print(f\"Would make API call for: {action}\")\n\n    def check_and_execute_rules(self):\n        \"\"\"Check all rules and execute actions for those that match\"\"\"\n        if not self.current_weather:\n            return False\n\n        triggered_actions = []\n\n        for rule in self.config[\"rules\"]:\n            if self.check_rule(rule):\n                print(f\"Rule triggered: {rule['condition']}\")\n                for action in rule[\"actions\"]:\n                    triggered_actions.append(action)\n\n        # Execute all triggered actions\n        for action in triggered_actions:\n            self.execute_action(action)\n\n        return len(triggered_actions) &gt; 0\n\n    def run_automation_loop(self):\n        \"\"\"Run the main automation loop\"\"\"\n        check_interval = self.config[\"check_interval_minutes\"] * 60\n\n        print(f\"Weather Home Automation started. Checking every {check_interval/60} minutes.\")\n        print(\"Press Ctrl+C to exit.\")\n\n        try:\n            while True:\n                print(f\"\\nChecking weather at {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}...\")\n                self.get_current_weather()\n\n                if self.current_weather:\n                    print(f\"Current conditions: {self.current_weather['conditions']}\")\n                    actions_triggered = self.check_and_execute_rules()\n\n                    if not actions_triggered:\n                        print(\"No actions triggered.\")\n\n                # Sleep until next check\n                print(f\"Next check in {check_interval/60} minutes.\")\n                time.sleep(check_interval)\n        except KeyboardInterrupt:\n            print(\"\\nWeather Home Automation stopped.\")\n\n# Run the automation system\nif __name__ == \"__main__\":\n    import re  # Required for regex in extract_conditions\n\n    automation = WeatherHomeAutomation()\n    automation.run_automation_loop()\n</code></pre> <p>Note: This project is conceptual and would need adaptation to work with specific smart home systems. It demonstrates the approach but doesn't include actual implementations for various smart home APIs.</p> <p>Extensions: - Add a web interface for configuration - Implement specific integrations for popular smart home platforms - Add machine learning to improve automation decisions based on past patterns</p>"},{"location":"mini-projects/advanced/weather-notification-system/","title":"Weather Notification System","text":"<p>Description: Create a program that sends notifications when specific weather conditions occur.</p> <p>Skills practiced: - Scheduled tasks - Notifications - Pattern matching - Configuration management</p> <p>Sample code:</p> <pre><code>import fetch_my_weather\nimport time\nimport json\nimport os\nfrom datetime import datetime\n\n# For Windows notifications\ntry:\n    from win10toast import ToastNotifier\n    toaster = ToastNotifier()\n    notification_system = \"windows\"\nexcept ImportError:\n    # For macOS notifications\n    try:\n        import subprocess\n        def notify_mac(title, message):\n            subprocess.run(['osascript', '-e', f'display notification \"{message}\" with title \"{title}\"'])\n        notification_system = \"mac\"\n    except:\n        # Fallback to console\n        notification_system = \"console\"\n\ndef send_notification(title, message):\n    \"\"\"Send a notification using platform-specific methods\"\"\"\n    print(f\"NOTIFICATION: {title} - {message}\")\n\n    if notification_system == \"windows\":\n        toaster.show_toast(title, message, duration=10)\n    elif notification_system == \"mac\":\n        notify_mac(title, message)\n    # For other platforms, we already printed to console\n\ndef load_config():\n    \"\"\"Load configuration or create default\"\"\"\n    config_file = \"weather_alerts_config.json\"\n\n    if os.path.exists(config_file):\n        try:\n            with open(config_file, \"r\") as f:\n                return json.load(f)\n        except:\n            print(\"Error loading config file, using defaults\")\n\n    # Default configuration\n    default_config = {\n        \"location\": \"\",  # Empty for auto-detect\n        \"check_interval_minutes\": 60,\n        \"alerts\": {\n            \"rain\": True,\n            \"snow\": True,\n            \"extreme_temp\": True,\n            \"extreme_temp_threshold_high\": 30,  # \u00b0C\n            \"extreme_temp_threshold_low\": 0,    # \u00b0C\n            \"wind\": True,\n            \"wind_threshold\": 50  # km/h\n        },\n        \"last_alerts\": {}\n    }\n\n    # Save default config\n    with open(config_file, \"w\") as f:\n        json.dump(default_config, f, indent=2)\n\n    return default_config\n\ndef save_config(config):\n    \"\"\"Save configuration\"\"\"\n    with open(\"weather_alerts_config.json\", \"w\") as f:\n        json.dump(config, f, indent=2)\n\ndef extract_temperature(weather_text):\n    \"\"\"Extract temperature from weather text\"\"\"\n    for line in weather_text.split('\\n'):\n        if '\u00b0C' in line:\n            parts = line.split('\u00b0C')[0].split()\n            if parts and parts[-1].replace('-', '').isdigit():\n                return int(parts[-1])\n    return None\n\ndef extract_wind_speed(weather_text):\n    \"\"\"Extract wind speed from weather text\"\"\"\n    for line in weather_text.split('\\n'):\n        if 'km/h' in line:\n            parts = line.split('km/h')[0].split()\n            if parts and parts[-1].isdigit():\n                return int(parts[-1])\n    return None\n\ndef check_weather_alerts():\n    \"\"\"Check weather and send alerts if conditions match\"\"\"\n    config = load_config()\n    location = config[\"location\"]\n    today = datetime.now().strftime(\"%Y-%m-%d\")\n\n    # Get current weather\n    weather = fetch_my_weather.get_weather(location=location, view_options=\"q\")\n\n    if isinstance(weather, str) and not weather.startswith(\"Error:\"):\n        alerts_triggered = []\n        weather_lower = weather.lower()\n\n        # Check for rain\n        if config[\"alerts\"][\"rain\"] and (\"rain\" in weather_lower or \"shower\" in weather_lower):\n            if \"rain\" not in config[\"last_alerts\"] or config[\"last_alerts\"][\"rain\"] != today:\n                alerts_triggered.append((\"Rain Alert\", \"Rain is expected today. Don't forget your umbrella!\"))\n                config[\"last_alerts\"][\"rain\"] = today\n\n        # Check for snow\n        if config[\"alerts\"][\"snow\"] and (\"snow\" in weather_lower or \"blizzard\" in weather_lower):\n            if \"snow\" not in config[\"last_alerts\"] or config[\"last_alerts\"][\"snow\"] != today:\n                alerts_triggered.append((\"Snow Alert\", \"Snow is expected today. Dress warmly!\"))\n                config[\"last_alerts\"][\"snow\"] = today\n\n        # Check for extreme temperatures\n        if config[\"alerts\"][\"extreme_temp\"]:\n            temp = extract_temperature(weather)\n            if temp is not None:\n                if temp &gt;= config[\"alerts\"][\"extreme_temp_threshold_high\"]:\n                    if \"high_temp\" not in config[\"last_alerts\"] or config[\"last_alerts\"][\"high_temp\"] != today:\n                        alerts_triggered.append((\"Heat Alert\", f\"High temperature of {temp}\u00b0C expected today. Stay hydrated!\"))\n                        config[\"last_alerts\"][\"high_temp\"] = today\n                elif temp &lt;= config[\"alerts\"][\"extreme_temp_threshold_low\"]:\n                    if \"low_temp\" not in config[\"last_alerts\"] or config[\"last_alerts\"][\"low_temp\"] != today:\n                        alerts_triggered.append((\"Cold Alert\", f\"Low temperature of {temp}\u00b0C expected today. Dress warmly!\"))\n                        config[\"last_alerts\"][\"low_temp\"] = today\n\n        # Check for strong wind\n        if config[\"alerts\"][\"wind\"]:\n            wind = extract_wind_speed(weather)\n            if wind is not None and wind &gt;= config[\"alerts\"][\"wind_threshold\"]:\n                if \"wind\" not in config[\"last_alerts\"] or config[\"last_alerts\"][\"wind\"] != today:\n                    alerts_triggered.append((\"Wind Alert\", f\"Strong winds of {wind} km/h expected today. Be careful outside!\"))\n                    config[\"last_alerts\"][\"wind\"] = today\n\n        # Send notifications for triggered alerts\n        for title, message in alerts_triggered:\n            send_notification(title, message)\n\n        # Save updated config with last alerts\n        save_config(config)\n\n        return len(alerts_triggered) &gt; 0\n    else:\n        print(f\"Error getting weather: {weather}\")\n        return False\n\ndef weather_alert_service():\n    \"\"\"Run the weather alert service continuously\"\"\"\n    config = load_config()\n    check_interval_minutes = config[\"check_interval_minutes\"]\n\n    print(f\"Weather Alert Service started. Checking every {check_interval_minutes} minutes.\")\n    print(f\"Press Ctrl+C to exit.\")\n\n    try:\n        while True:\n            print(f\"\\nChecking weather alerts at {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}...\")\n            alerts_sent = check_weather_alerts()\n\n            if not alerts_sent:\n                print(\"No new alerts triggered.\")\n\n            # Update interval from config in case it was changed\n            config = load_config()\n            check_interval_minutes = config[\"check_interval_minutes\"]\n\n            # Sleep until next check\n            print(f\"Next check in {check_interval_minutes} minutes.\")\n            time.sleep(check_interval_minutes * 60)\n    except KeyboardInterrupt:\n        print(\"\\nWeather Alert Service stopped.\")\n\n# Run the service\nif __name__ == \"__main__\":\n    weather_alert_service()\n</code></pre> <p>Extensions: - Create a GUI for configuring alert settings - Add support for email or SMS notifications - Implement a machine learning model to predict when alerts might be needed</p>"},{"location":"mini-projects/beginner/multi-city-weather-checker/","title":"Multi-City Weather Checker","text":"<p>Description: Create a program that compares the weather in multiple cities of your choice.</p> <p>Skills practiced: - Working with lists - Loops - Function calls with parameters</p> <p>Sample code:</p> <pre><code>import fetch_my_weather\nimport time\n\ndef check_multiple_cities(cities):\n    print(\"Checking weather in multiple cities...\\n\")\n\n    for city in cities:\n        print(f\"Weather in {city}:\")\n        weather = fetch_my_weather.get_weather(location=city, view_options=\"0q\")\n\n        if isinstance(weather, str) and not weather.startswith(\"Error:\"):\n            print(weather)\n        else:\n            print(f\"Could not get weather for {city}: {weather}\")\n\n        print(\"-\" * 40)\n        time.sleep(1)  # Be nice to the weather service\n\n    print(\"Weather check complete!\")\n\n# List of cities to check\nmy_cities = [\"New York\", \"London\", \"Tokyo\", \"Sydney\", \"Rio de Janeiro\"]\n\n# Run the function\ncheck_multiple_cities(my_cities)\n</code></pre> <p>Extensions: - Allow the user to input their own list of cities - Sort the cities from warmest to coldest</p>"},{"location":"mini-projects/beginner/personal-weather-dashboard/","title":"Personal Weather Dashboard","text":"<p>Description: Create a simple program that shows the weather for your location when you start your computer.</p> <p>Skills practiced: - Basic function calls - String formatting - Printing to console</p> <p>Sample code:</p> <pre><code>import fetch_my_weather\n\ndef show_my_weather():\n    # Get current location weather\n    weather = fetch_my_weather.get_weather(view_options=\"q\")\n\n    # Print a nice header\n    print(\"=\" * 50)\n    print(\"TODAY'S WEATHER\")\n    print(\"=\" * 50)\n\n    # Print the weather\n    print(weather)\n\n    print(\"=\" * 50)\n    print(\"Have a great day!\")\n\nif __name__ == \"__main__\":\n    show_my_weather()\n</code></pre> <p>Extensions: - Add a greeting based on the time of day (\"Good morning!\", etc.) - Save to a file instead of printing</p>"},{"location":"mini-projects/beginner/weather-image-saver/","title":"Weather Image Saver","text":"<p>Description: Create a program that saves the current weather as a PNG image.</p> <p>Skills practiced: - Working with binary data - File I/O - Error handling</p> <p>Sample code:</p> <pre><code>import fetch_my_weather\nimport os\nfrom datetime import datetime\n\ndef save_weather_image(location, save_directory=\"weather_images\"):\n    # Create the directory if it doesn't exist\n    if not os.path.exists(save_directory):\n        os.makedirs(save_directory)\n\n    # Get current date and time for the filename\n    current_time = datetime.now().strftime(\"%Y-%m-%d_%H-%M-%S\")\n    filename = f\"{save_directory}/{location.replace(' ', '_')}_{current_time}.png\"\n\n    # Get the weather as PNG\n    print(f\"Getting weather for {location}...\")\n    weather_png = fetch_my_weather.get_weather(location=location, is_png=True)\n\n    # Check if we got an error\n    if not isinstance(weather_png, bytes):\n        print(f\"Error getting weather: {weather_png}\")\n        return False\n\n    # Save the PNG to a file\n    try:\n        with open(filename, \"wb\") as f:\n            f.write(weather_png)\n        print(f\"Saved weather image to {filename}\")\n        return True\n    except Exception as e:\n        print(f\"Error saving file: {e}\")\n        return False\n\n# Save weather for New York\nsave_weather_image(\"New York\")\n</code></pre> <p>Extensions: - Add options for transparent or padded images - Create a daily weather logger that saves an image every day</p>"},{"location":"mini-projects/intermediate/weather-based-wallpaper-changer/","title":"Weather-based Wallpaper Changer","text":"<p>Description: Create a program that changes your desktop wallpaper based on the current weather.</p> <p>Skills practiced: - System integration - Image handling - Conditional logic - Scheduled tasks</p> <p>Sample code:</p> <pre><code>import fetch_my_weather\nimport os\nimport platform\nimport ctypes\nimport subprocess\nimport tempfile\nfrom datetime import datetime\n\ndef get_weather_condition():\n    \"\"\"Get the current weather condition\"\"\"\n    weather = fetch_my_weather.get_weather(view_options=\"0q\")\n\n    if isinstance(weather, str) and not weather.startswith(\"Error:\"):\n        # Simple weather condition detection (could be improved)\n        weather_lower = weather.lower()\n\n        if \"rain\" in weather_lower or \"shower\" in weather_lower:\n            return \"rainy\"\n        elif \"snow\" in weather_lower or \"blizzard\" in weather_lower:\n            return \"snowy\"\n        elif \"cloud\" in weather_lower or \"overcast\" in weather_lower:\n            return \"cloudy\"\n        elif \"sunny\" in weather_lower or \"clear\" in weather_lower:\n            return \"sunny\"\n        else:\n            # Default to current weather image\n            return \"current\"\n    else:\n        print(f\"Error getting weather: {weather}\")\n        return None\n\ndef set_wallpaper(image_path):\n    \"\"\"Set the desktop wallpaper (platform specific)\"\"\"\n    try:\n        # Windows\n        if platform.system() == \"Windows\":\n            ctypes.windll.user32.SystemParametersInfoW(20, 0, image_path, 0)\n            return True\n        # macOS\n        elif platform.system() == \"Darwin\":\n            script = f'''\n            tell application \"Finder\"\n                set desktop picture to POSIX file \"{image_path}\"\n            end tell\n            '''\n            subprocess.run(['osascript', '-e', script], check=True)\n            return True\n        # Linux (assuming GNOME)\n        elif platform.system() == \"Linux\":\n            subprocess.run(['gsettings', 'set', 'org.gnome.desktop.background', \n                           'picture-uri', f\"file://{image_path}\"], check=True)\n            return True\n        else:\n            print(f\"Unsupported platform: {platform.system()}\")\n            return False\n    except Exception as e:\n        print(f\"Error setting wallpaper: {e}\")\n        return False\n\ndef change_wallpaper_based_on_weather():\n    \"\"\"Change wallpaper based on current weather\"\"\"\n    # Get current weather condition\n    condition = get_weather_condition()\n\n    if condition == \"current\":\n        # Use current weather image as wallpaper\n        temp_file = os.path.join(tempfile.gettempdir(), f\"weather_{datetime.now().strftime('%Y%m%d_%H%M%S')}.png\")\n\n        # Get current weather as PNG with padding for better wallpaper fit\n        weather_png = fetch_my_weather.get_weather(is_png=True, png_options=\"p\")\n\n        if isinstance(weather_png, bytes):\n            with open(temp_file, \"wb\") as f:\n                f.write(weather_png)\n\n            # Set as wallpaper\n            if set_wallpaper(temp_file):\n                print(f\"Set current weather as wallpaper: {temp_file}\")\n                return True\n    else:\n        # In a real application, you would have custom wallpapers for each condition\n        # For this example, we'll use the weather image\n        print(f\"Weather condition: {condition}\")\n\n        # Get weather image\n        temp_file = os.path.join(tempfile.gettempdir(), f\"weather_{condition}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.png\")\n\n        # Get current weather as PNG\n        weather_png = fetch_my_weather.get_weather(is_png=True, png_options=\"p\")\n\n        if isinstance(weather_png, bytes):\n            with open(temp_file, \"wb\") as f:\n                f.write(weather_png)\n\n            # Set as wallpaper\n            if set_wallpaper(temp_file):\n                print(f\"Set {condition} weather as wallpaper: {temp_file}\")\n                return True\n\n    return False\n\n# Run the function\nprint(\"Changing wallpaper based on weather...\")\nsuccess = change_wallpaper_based_on_weather()\nif success:\n    print(\"Wallpaper changed successfully!\")\nelse:\n    print(\"Failed to change wallpaper.\")\n</code></pre> <p>Note: This script attempts to work on Windows, macOS, and Linux, but platform-specific behavior might require adjustments.</p> <p>Extensions: - Add custom wallpapers for different weather conditions - Create a scheduler that updates the wallpaper every few hours - Add transition effects between wallpapers</p>"},{"location":"mini-projects/intermediate/weather-mood-recommender/","title":"Weather Mood Recommender","text":"<p>Description: Create a program that suggests activities based on the weather.</p> <p>Skills practiced: - String parsing - Conditional logic - Dictionary usage</p> <p>Sample code:</p> <pre><code>import fetch_my_weather\nimport random\n\n# Activities based on weather conditions\nactivities = {\n    \"sunny\": [\"Go for a walk\", \"Have a picnic\", \"Visit the park\", \"Go cycling\"],\n    \"rainy\": [\"Read a book\", \"Watch a movie\", \"Visit a museum\", \"Cook a new recipe\"],\n    \"cloudy\": [\"Go shopping\", \"Visit friends\", \"Go to a caf\u00e9\", \"Take photographs\"],\n    \"snowy\": [\"Build a snowman\", \"Go sledding\", \"Make hot chocolate\", \"Stay cozy inside\"],\n    \"cold\": [\"Visit a museum\", \"Go to a coffee shop\", \"Try a new restaurant\", \"Go ice skating\"],\n    \"hot\": [\"Go swimming\", \"Have ice cream\", \"Go to the beach\", \"Stay in air conditioning\"]\n}\n\ndef recommend_activity(location=\"\"):\n    # Get weather data\n    weather_data = fetch_my_weather.get_weather(location=location, view_options=\"q\")\n\n    if isinstance(weather_data, str) and not weather_data.startswith(\"Error:\"):\n        # Determine weather condition (this is a simplified approach)\n        weather_lower = weather_data.lower()\n\n        if \"sunny\" in weather_lower or \"clear\" in weather_lower:\n            condition = \"sunny\"\n        elif \"rain\" in weather_lower or \"drizzle\" in weather_lower or \"shower\" in weather_lower:\n            condition = \"rainy\"\n        elif \"cloud\" in weather_lower or \"overcast\" in weather_lower:\n            condition = \"cloudy\"\n        elif \"snow\" in weather_lower or \"blizzard\" in weather_lower:\n            condition = \"snowy\"\n        elif any(temp in weather_lower for temp in [\"0 \u00b0c\", \"1 \u00b0c\", \"2 \u00b0c\", \"3 \u00b0c\", \"4 \u00b0c\", \"5 \u00b0c\"]):\n            condition = \"cold\"\n        elif any(temp in weather_lower for temp in [\"30 \u00b0c\", \"31 \u00b0c\", \"32 \u00b0c\", \"33 \u00b0c\", \"34 \u00b0c\", \"35 \u00b0c\"]):\n            condition = \"hot\"\n        else:\n            condition = random.choice([\"sunny\", \"cloudy\", \"rainy\"])\n\n        # Get random activity for the condition\n        if condition in activities:\n            activity = random.choice(activities[condition])\n            return f\"Based on the {condition} weather, you could: {activity}\"\n        else:\n            return \"No specific recommendation for this weather.\"\n    else:\n        return f\"Could not get weather: {weather_data}\"\n\n# Location to check\nmy_location = \"London\"\n\n# Get and print the recommendation\nprint(f\"Weather activity recommendation for {my_location}:\")\nrecommendation = recommend_activity(my_location)\nprint(recommendation)\n</code></pre> <p>Extensions: - Add more specific weather conditions and activities - Allow users to add their own activities to the list - Factor in the time of day for recommendations</p>"},{"location":"mini-projects/intermediate/weekly-weather-forecast-tracker/","title":"Weekly Weather Forecast Tracker","text":"<p>Description: Create a program that tracks and compares weather forecasts with actual weather.</p> <p>Skills practiced: - File I/O - Data persistence - Date/time handling - Text parsing</p> <p>Sample code:</p> <pre><code>import fetch_my_weather\nimport csv\nimport os\nfrom datetime import datetime, timedelta\n\ndef extract_temperature(weather_text):\n    \"\"\"Extract temperature from weather text (simple approach)\"\"\"\n    for line in weather_text.split('\\n'):\n        if '\u00b0C' in line:\n            parts = line.split('\u00b0C')[0].split()\n            if parts and parts[-1].replace('-', '').isdigit():\n                return int(parts[-1])\n    return None\n\ndef record_forecast():\n    \"\"\"Record today's forecast for the next few days\"\"\"\n    location = \"London\"  # Change to your location\n\n    # Get the weather forecast\n    forecast = fetch_my_weather.get_weather(location=location)\n\n    if isinstance(forecast, str) and not forecast.startswith(\"Error:\"):\n        # Record date and forecast\n        today = datetime.now()\n\n        # Check if forecast file exists, create it if not\n        file_exists = os.path.isfile('weather_forecast.csv')\n\n        with open('weather_forecast.csv', 'a', newline='') as csvfile:\n            fieldnames = ['forecast_date', 'target_date', 'forecasted_temp', 'actual_temp']\n            writer = csv.DictWriter(csvfile, fieldnames=fieldnames)\n\n            if not file_exists:\n                writer.writeheader()\n\n            # Extract forecasted temperatures (simplified approach)\n            # In reality, you'd want to parse the forecast more carefully\n            forecast_lines = forecast.split('\\n')\n            for i in range(1, 4):  # Look at next 3 days\n                target_date = today + timedelta(days=i)\n                target_date_str = target_date.strftime('%Y-%m-%d')\n\n                # Get forecasted temperature (simplified)\n                temp = extract_temperature(forecast)\n\n                if temp is not None:\n                    writer.writerow({\n                        'forecast_date': today.strftime('%Y-%m-%d'),\n                        'target_date': target_date_str,\n                        'forecasted_temp': temp,\n                        'actual_temp': ''  # Will be filled in later\n                    })\n                    print(f\"Recorded forecast for {target_date_str}: {temp}\u00b0C\")\n    else:\n        print(f\"Could not get forecast: {forecast}\")\n\ndef update_actual_temperatures():\n    \"\"\"Update recorded forecasts with actual temperatures\"\"\"\n    today = datetime.now().strftime('%Y-%m-%d')\n\n    # Get today's actual weather\n    actual_weather = fetch_my_weather.get_weather(view_options=\"0q\")\n\n    if isinstance(actual_weather, str) and not actual_weather.startswith(\"Error:\"):\n        # Extract actual temperature\n        actual_temp = extract_temperature(actual_weather)\n\n        if actual_temp is not None:\n            # Read the existing CSV\n            rows = []\n            with open('weather_forecast.csv', 'r', newline='') as csvfile:\n                reader = csv.DictReader(csvfile)\n                for row in reader:\n                    # Update rows where target_date is today and actual_temp is empty\n                    if row['target_date'] == today and not row['actual_temp']:\n                        row['actual_temp'] = actual_temp\n                        print(f\"Updated actual temperature for {today}: {actual_temp}\u00b0C\")\n                    rows.append(row)\n\n            # Write the updated data back\n            with open('weather_forecast.csv', 'w', newline='') as csvfile:\n                fieldnames = ['forecast_date', 'target_date', 'forecasted_temp', 'actual_temp']\n                writer = csv.DictWriter(csvfile, fieldnames=fieldnames)\n                writer.writeheader()\n                writer.writerows(rows)\n    else:\n        print(f\"Could not get actual weather: {actual_weather}\")\n\ndef show_forecast_accuracy():\n    \"\"\"Show how accurate the forecasts have been\"\"\"\n    if not os.path.isfile('weather_forecast.csv'):\n        print(\"No forecast data available yet.\")\n        return\n\n    # Read the CSV and calculate accuracy\n    with open('weather_forecast.csv', 'r', newline='') as csvfile:\n        reader = csv.DictReader(csvfile)\n\n        total_comparisons = 0\n        total_difference = 0\n\n        for row in reader:\n            if row['actual_temp'] and row['forecasted_temp']:\n                forecasted = int(row['forecasted_temp'])\n                actual = int(row['actual_temp'])\n                difference = abs(forecasted - actual)\n\n                print(f\"Date: {row['target_date']}\")\n                print(f\"  Forecast made on: {row['forecast_date']}\")\n                print(f\"  Forecasted temp: {forecasted}\u00b0C\")\n                print(f\"  Actual temp: {actual}\u00b0C\")\n                print(f\"  Difference: {difference}\u00b0C\")\n                print(\"-\" * 30)\n\n                total_comparisons += 1\n                total_difference += difference\n\n        if total_comparisons &gt; 0:\n            average_difference = total_difference / total_comparisons\n            print(f\"\\nAverage forecast difference: {average_difference:.1f}\u00b0C over {total_comparisons} days\")\n        else:\n            print(\"No completed forecast data available yet.\")\n\n# Run the functions\nprint(\"=== Weather Forecast Tracker ===\")\nprint(\"1. Recording forecast...\")\nrecord_forecast()\n\nprint(\"\\n2. Updating actual temperatures...\")\nupdate_actual_temperatures()\n\nprint(\"\\n3. Forecast accuracy report:\")\nshow_forecast_accuracy()\n</code></pre> <p>Extensions: - Add more weather data points (precipitation, wind, etc.) - Create visualization of forecast accuracy - Set up an automated system to run daily</p>"}]}